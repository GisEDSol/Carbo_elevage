---
title: "Traitement des données de la BDAT"
author: "Jean-Baptiste Paroissien"
date: "20/12/2016"
output: html_notebook
fig_caption: yes
highlight: zenburn
number_sections: yes
theme: spacelab
---

```{r setup, include=TRUE,warning=FALSE,echo=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("/media/sf_GIS_ED/Dev/")
# Chargement des librairies
library(RODBC);library(gdata);library(rgrass7);library(fields);library(geoR);library(stringr);library(ggplot2);library(plotly);library(rgdal);library(maptools);library(RColorBrewer);library(classInt);library(devtools);
library(Hmisc);library(gridExtra);library(mapproj);library(wesanderson);library(data.table);library(FactoMineR);library(knitr)

# Définition des principaux répertoires de travail
masterrep <- "/media/sf_GIS_ED/Dev/"#Chemin initial vers le répertoire de travail (à changer si changement d'arborescence)

repfonctions <- paste(masterrep,"Scripts/master/Fonctions/R/",sep="")
repagreste <- paste(masterrep,"Data/Vegetation_Occup/Agreste/Disar/",sep="")
repsortie <- paste(masterrep,"Scripts/master/Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers
# Mise en place de la connexion ODBC
loc <- odbcConnect("solelevage",case="postgresql", believeNRows=FALSE)

# Mise en place de la connexion ODBC
loc <- odbcConnect("solelevage",case="postgresql", believeNRows=FALSE)

# Chargement de la fonction cartoperiod
source(paste(repfonctions,"cartoperiod.R",sep=""))

# Fonction très pratique pour remplacer une suite de charact?res par une autre
gsub2 <- function(pattern, replacement, x, ...) {
  for(i in 1:length(pattern))
    x <- gsub(pattern[i], replacement[i], x, ...)
  x
}
```

```{r, tidy=FALSE,eval=TRUE}
Sys.Date()
sessionInfo()
```

# Objectifs

Ce fichier de suivi a pour but de centraliser l'ensemble des analyses temporelle d'une variable pédologique de la BDAT. Ce travail est organisé de la façon suivante :

- Analyse des histogrammes de fréquence et tests statistiques pour chacune des périodes de temps analysées,
- Représentation cartographique par canton
- Analyse des facteurs explicatifs 



# Etape 0 : Préparation des données et statistiques

Les données de la BDAT sont ré-organisées pour faciliter les traitements statistiques et la production de graphique. La fonction `melt` est utilisée pour transformer les données d'un format "large" à un format "long".

```{r,highlight=TRUE,eval=FALSE}
# Paramètres
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" # Configuration de la connexion vers le PostGIS
varia <- c("corgox_med") # Variable à analyser 
period <- c("9094","9599","0004","0509")
mapcanton <- readOGR(dsn = dsn, "canton")
id <- c("code_canton","code_reg","nom_region") #Nom de l'identifiant

# Boucle pour séparer l'année du nom de la variable étudiée
cpt <- 0
for(i in varia){
  print(i)
  cpt <- cpt + 1
  variaperiod <- paste(i,period,sep="")  
  
  stats.canton <- mapcanton[,c(id,variaperiod)]
  # Modification de la structure de la table
  stats.canton <- melt(data=stats.canton@data,id.vars=id)
  # Extraction de l'année et renommage des colonnes
  stats.canton[,"variable"] <- as.character(unlist(regmatches(stats.canton[,"variable"],gregexpr('[0-9]+.[0-9]+',stats.canton[,"variable"]))))
  colnames(stats.canton)[4:5] <- c("annees",i) #revoir la sélection de ces colonnes
    
  if(cpt==1){
    # Construction de la première table
    melt.canton <- stats.canton
  }else{
    # Ajout à chaque itération de la variable (i)
    melt.canton <- merge(melt.canton,stats.canton, by.x=c(id,"annees"), by.y=c(id,"annees"),all.x=TRUE,all.y=TRUE)
  }
}

# Création finale de la table
melted.bdat <- melt(data=melt.canton,id.vars=c(id,"annees"))
melted.bdat$annees <- as.character(melted.bdat$annees)

# Enregistrement dans le schema RA
tablename <- paste("bdat.","melted_bdat",sep="")
sqlQuery(loc,paste("drop table if exists ",tablename,sep=""))
sqlSave(loc,melted.bdat,tablename=tablename)
```


# Etape 1 : Analyse des teneurs par période

Cette première étape permettra d’analyser les différences entre chacune des périodes. Les rendus de cette première étape sont les suivants :

- statistiques descriptives et courbes de fréquences cumulées ;
- boxplot accompagnés de tests de « significacité » des différences entre les périodes (probablement test Wilkcoxon).

## Fréquences cumulées

Les fréquences cumulées permettent...
Scripts pour représenter les fréquences cumulées pour une série de période donnée
Voir également http://elcep.legtux.org/?cat=2 pour une autre représentation graphique

```{r,highlight=TRUE,eval=FALSE}
period <- c("9094","9599","0004","0509")
variable <- "corgox_med"
xlabel="Carbone organique (g/kg)"
ylabel="Fréquence"
#dep <- c("17,16,86,79") # Voir pour la sélection de plusieurs département.
#reg <- "54" #pour région Poitou Charentes 

cpt <- 0
for(i in period){
  cpt <- cpt + 1
  
  tableBDAT <- sqlQuery(loc,paste("select ",variable,"
                    from bdat.bdat_canton_",i," as s1
                    inner join canton as cant on cant.code_canton=s1.code_canton",sep=""))
                    #where code_reg like '",reg,"'",sep=""))
  
  # Selection des cantons avec des données
  tableBDAT <- tableBDAT[!is.na(tableBDAT),]  
  
  x <- sort(tableBDAT)
  q <- ppoints(length(tableBDAT))
  
  # Configuration du graphique
  nperiod <- length(period)
  colors <- cm.colors(nperiod)  
  linetype <- c(1:nperiod)
  plotchar <- seq(18,18+nperiod,1)
  
  # Fréquence cumulée
  if(cpt==1){
    plot(q~x, col=colors[cpt],type='l',xlab=xlabel,ylab=ylabel,lwd=3)
    }else{
      lines(x,q, pch = plotchar[cpt], type = "l", col=colors[cpt],lty=linetype[cpt],lwd=3)
    }
  # Boxplot ?
}
```

## Statistiques descriptives

### Tableaux

```{r,highlight=TRUE,eval=FALSE}
# Lecture de la table (revoir la lecture de la table, problème avec le character annees non pris en compte)
melted.bdat <- sqlQuery(loc,paste("select value,annees::text from bdat.melted_bdat",sep=""),as.is=c(FALSE,TRUE))
melted.bdat <- melted.bdat[complete.cases(melted.bdat),]

# Résumé des statistiques 
#by(melted.bdat[,"value"],melted.bdat[,"annees"],summary)
summarytable <- tapply(melted.bdat[,"value"], melted.bdat[,"annees"],summary)
kable(summarytable)
```

### Tests statistiques

```{r,highlight=TRUE,eval=FALSE}
rest <- array(NA, dim = c(25, 2), list(loop=1:25,mod=c("model","pvalue")))

cpt <- 0
for(i in 1:4){
	for(a in 1:4){
		cpt <- cpt+1
		rest[cpt,"model"] <- paste(names(dfdviactuel[i]),"+",names(dfdviactuel[a]))
		rest[cpt,"pvalue"] <- wilcox.test(dfdviactuel[,i],dfdviactuel[,a])$p.value
	}
}


```
### Boxplot

```{r,highlight=TRUE,eval=FALSE}
varia <- c("corgox_med") # Variable à analyser 
period <- c("9094","9599","0004","0509")

#melted.RA <- sqlQuery(loc,paste("select * from ra.melted_RA where code_reg similar to '",reg,"'",sep=""))
melted.bdat <- sqlQuery(loc,paste("select value,variable,annees,code_reg,nom_region from bdat.melted_bdat",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE))
melted.bdat <- melted.bdat[complete.cases(melted.bdat),]

cpt <- 0
for(i in varia){
  cpt <- cpt + 1
  melted.RAsth <- melted.bdat[melted.bdat["variable"] == i,]

    p <- ggplot(melted.RAsth) +
            geom_boxplot(aes(x=annees,y=value,col=nom_region))+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=nom_region,fill=nom_region),method=loess)+
            scale_x_discrete("Années")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
  
  ggsave(p,file = paste(repsortie,"boxplotbdat.png",sep=""), width = 15, height = 10)  
  }
```

```{r,highlight=TRUE,eval=FALSE}
p <- ggplot(melted.RAsth) +
            geom_boxplot(aes(x=annees,y=value,col=nom_region))+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=nom_region,fill=nom_region),method=loess)+
            scale_x_discrete("Années")+scale_y_continuous("Pourcentage")+labs(title=i)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
```

## Cartographie

Dans cette partie, des cartes peuvent être produites selon plusieurs arguments (reste à définir) :

- stratification spatiale (région ou autre entités spatiales),
- stratification temporelle (groupe de plusieurs années).

```{r,highlight=TRUE,eval=FALSE}
# Paramètres #################
tablecarto <- "canton" #Nom de la table utilisée pour la cartographie (table postgis)
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" #Paramètre de connexion vers la base de données
period <- c("9094","9599","0004","0509") #
variable <- "corgox_med"
variablecarto <- paste(variable,period,sep="")#variable à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- "YlGnBu" #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Teneur en carbone organique (g/kg)" #label de la variable

cartoperiod(dsn,tablecarto,period,variable,nclasse,style_classe,couleur,l_legend,repsortie,nomfichier,dept=FALSE,reg=FALSE)
```

  
# test

```{r,highlight=TRUE,eval=FALSE}
library(shiny)
library(leaflet)

library(maps)
mapStates = map("state", fill = TRUE, plot = FALSE)

leaflet(data = mapStates) %>% addTiles() %>%
  addPolygons(fillColor = topo.colors(10, alpha = NULL), stroke = FALSE)


leaflet(data = map) %>% addTiles() %>%
  addPolygons(fillColor = topo.colors(10, alpha = NULL), stroke = FALSE)



r_colors <- rgb(t(col2rgb(colors()) / 255))
names(r_colors) <- colors()

ui <- fluidPage(
  leafletOutput("mymap"),
  p())

server <- function(input, output, session) {
  output$mymap <- renderLeaflet({
    leaflet() %>%
    addPolygons(stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5,) %>%
    addProviderTiles("Test",options = providerTileOptions(noWrap = TRUE))
    })
}

shinyApp(ui, server)
```

```{r,highlight=TRUE,eval=FALSE}

library("leaflet")
library("data.table")
library("sp")
library("rgdal")
# library("maptools")
library("KernSmooth")

inurl <- "https://data.cityofchicago.org/api/views/22s8-eq8h/rows.csv?accessType=DOWNLOAD"
infile <- "mvthefts.csv"

## LOAD DATA
## Also, clean up variable names, and convert dates
if(!file.exists(infile)){
    download.file(url = inurl, destfile = infile)
}
dat <- data.table::fread(infile)
setnames(dat, tolower(colnames(dat)))
setnames(dat, gsub(" ", "_", colnames(dat)))
dat <- dat[!is.na(longitude)]
dat[ , date := as.IDate(date, "%m/%d/%Y")]

## MAKE CONTOUR LINES
## Note, bandwidth choice is based on MASS::bandwidth.nrd()
kde <- bkde2D(dat[ , list(longitude, latitude)],
              bandwidth=c(.0045, .0068), gridsize = c(100,100))
CL <- contourLines(kde$x1 , kde$x2 , kde$fhat)

## EXTRACT CONTOUR LINE LEVELS
LEVS <- as.factor(sapply(CL, `[[`, "level"))
NLEV <- length(levels(LEVS))

## CONVERT CONTOUR LINES TO POLYGONS
pgons <- lapply(1:length(CL), function(i)
    Polygons(list(Polygon(cbind(CL[[i]]$x, CL[[i]]$y))), ID=i))
spgons = SpatialPolygons(pgons)

## Leaflet map with polygons
leaflet(spgons) %>% addTiles() %>% 
    addPolygons(color = heat.colors(NLEV, NULL)[LEVS])


## Leaflet map with points and polygons
## Note, this shows some problems with the KDE, in my opinion...
## For example there seems to be a hot spot at the intersection of Mayfield and
## Fillmore, but it's not getting picked up.  Maybe a smaller bw is a good idea?

leaflet(spgons) %>% addTiles() %>%
    addPolygons(color = heat.colors(NLEV, NULL)[LEVS]) %>%
    addCircles(lng = dat$longitude, lat = dat$latitude,
               radius = .5, opacity = .2, col = "blue")




## Leaflet map with polygons, using Spatial Data Frame
## Initially I thought that the data frame structure was necessary
## This seems to give the same results, but maybe there are some 
## advantages to using the data.frame, e.g. for adding more columns
spgonsdf = SpatialPolygonsDataFrame(Sr = spgons,
                                    data = data.frame(level = LEVS),
                                    match.ID = TRUE)
leaflet() %>% addTiles() %>%
    addPolygons(data = spgonsdf,
                color = heat.colors(NLEV, NULL)[spgonsdf@data$level])

```













