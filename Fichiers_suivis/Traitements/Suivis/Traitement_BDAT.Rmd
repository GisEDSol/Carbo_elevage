---
title: "Traitement des données de la BDAT"
author: "Jean-Baptiste Paroissien"
date: "20/12/2016"
output: html_notebook
fig_caption: yes
highlight: zenburn
number_sections: yes
theme: spacelab
---

```{r setup, include=TRUE,warning=FALSE,echo=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("/media/sf_GIS_ED/Dev/")
# Chargement des librairies
library(RODBC);library(gdata);library(rgrass7);library(fields);library(geoR);library(stringr);library(ggplot2);library(plotly);library(rgdal);library(maptools);library(RColorBrewer);library(classInt);library(devtools);
library(Hmisc);library(gridExtra);library(mapproj);library(wesanderson);library(data.table);library(FactoMineR);library(knitr)

# Définition des principaux répertoires de travail
masterrep <- "/media/sf_GIS_ED/Dev/"#Chemin initial vers le répertoire de travail (à changer si changement d'arborescence)

repagreste <- paste(masterrep,"Data/Vegetation_Occup/Agreste/Disar/",sep="")
repsortie <- paste(masterrep,"Scripts/master/Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers
# Mise en place de la connexion ODBC
loc <- odbcConnect("solelevage",case="postgresql", believeNRows=FALSE)

# Fonction très pratique pour remplacer une suite de charact?res par une autre
gsub2 <- function(pattern, replacement, x, ...) {
  for(i in 1:length(pattern))
    x <- gsub(pattern[i], replacement[i], x, ...)
  x
}
```

```{r, tidy=FALSE,eval=TRUE}
Sys.Date()
sessionInfo()
```

# Objectifs

Ce fichier de suivi a pour but de centraliser l'ensemble des analyses temporelle d'une variable pédologique de la BDAT. Ce travail est organisé de la façon suivante :

- Analyse des histogrammes de fréquence et tests statistiques pour chacune des périodes de temps analysées,
- Représentation cartographique par canton
- Analyse des facteurs explicatifs 



# Etape 0 : Préparation des données et statistiques

Les données de la BDAT sont ré-organisées pour faciliter les traitements statistiques et la production de graphique. La fonction `melt` est utilisée pour transformer les données d'un format "large" à un format "long".

```{r,highlight=TRUE,eval=FALSE}
# Paramètres
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" # Configuration de la connexion vers le PostGIS
varia <- c("corgox_med") # Variable à analyser 
period <- c("9094","9599","0004","0509")
mapcanton <- readOGR(dsn = dsn, "canton")
id <- c("code_canton","code_reg","nom_region") #Nom de l'identifiant

# Boucle pour séparer l'année du nom de la variable étudiée
cpt <- 0
for(i in varia){
  print(i)
  cpt <- cpt + 1
  variaperiod <- paste(i,period,sep="")  
  
  stats.canton <- mapcanton[,c(id,variaperiod)]
  # Modification de la structure de la table
  stats.canton <- melt(data=stats.canton@data,id.vars=id)
  # Extraction de l'année et renommage des colonnes
  stats.canton[,"variable"] <- as.character(unlist(regmatches(stats.canton[,"variable"],gregexpr('[0-9]+.[0-9]+',stats.canton[,"variable"]))))
  colnames(stats.canton)[4:5] <- c("annees",i) #revoir la sélection de ces colonnes
    
  if(cpt==1){
    # Construction de la première table
    melt.canton <- stats.canton
  }else{
    # Ajout à chaque itération de la variable (i)
    melt.canton <- merge(melt.canton,stats.canton, by.x=c(id,"annees"), by.y=c(id,"annees"),all.x=TRUE,all.y=TRUE)
  }
}

# Création finale de la table
melted.bdat <- melt(data=melt.canton,id.vars=c(id,"annees"))
melted.bdat$annees <- as.character(melted.bdat$annees)

# Enregistrement dans le schema RA
tablename <- paste("bdat.","melted_bdat",sep="")
sqlQuery(loc,paste("drop table if exists ",tablename,sep=""))
sqlSave(loc,melted.bdat,tablename=tablename)
```


# Etape 1 : Analyse des teneurs par période

Cette première étape permettra d’analyser les différences entre chacune des périodes. Les rendus de cette première étape sont les suivants :

- statistiques descriptives et courbes de fréquences cumulées ;
- boxplot accompagnés de tests de « significacité » des différences entre les périodes (probablement test Wilkcoxon).

## Fréquences cumulées

Les fréquences cumulées permettent...
Scripts pour représenter les fréquences cumulées pour une série de période donnée
Voir également http://elcep.legtux.org/?cat=2 pour une autre représentation graphique

```{r,highlight=TRUE,eval=FALSE}
period <- c("9094","9599","0004","0509")
variable <- "corgox_med"
xlabel="Carbone organique (g/kg)"
ylabel="Fréquence"
#dep <- c("17,16,86,79") # Voir pour la sélection de plusieurs département.
#reg <- "54" #pour région Poitou Charentes 

cpt <- 0
for(i in period){
  cpt <- cpt + 1
  
  tableBDAT <- sqlQuery(loc,paste("select ",variable,"
                    from bdat.bdat_canton_",i," as s1
                    inner join canton as cant on cant.code_canton=s1.code_canton",sep=""))
                    #where code_reg like '",reg,"'",sep=""))
  # Selection des cantons avec des données
  tableBDAT <- tableBDAT[!is.na(tableBDAT),]  
  
  x <- sort(tableBDAT)
  q <- ppoints(length(tableBDAT))
  
  # Configuration du graphique
  nperiod <- length(period)
  colors <- cm.colors(nperiod)  
  linetype <- c(1:nperiod)
  plotchar <- seq(18,18+nperiod,1)
  
  # Fréquence cumulée
  if(cpt==1){
    plot(q~x, col=colors[cpt],type='l',xlab=xlabel,ylab=ylabel,lwd=3)
    }else{
      lines(x,q, pch = plotchar[cpt], type = "l", col=colors[cpt],lty=linetype[cpt],lwd=3)
    }
  # Boxplot ?
}
```

## Statistiques descriptives

### Tableaux

```{r,highlight=TRUE,eval=FALSE}
# Lecture de la table (revoir la lecture de la table, problème avec le character annees non pris en compte)
melted.bdat <- sqlQuery(loc,paste("select * from bdat.melted_bdat",sep=""))
melted.bdat <- melted.bdat[complete.cases(melted.bdat),]

# Résumé des statistiques 
by(melted.bdat[,c("value","annees")],as.character(melted.bdat[,"annees"]),summary)
```

### Boxplot

```{r,highlight=TRUE,eval=FALSE}
varia <- c("corgox_med") # Variable à analyser 
period <- c("9094","9599","0004","0509")

#melted.RA <- sqlQuery(loc,paste("select * from ra.melted_RA where code_reg similar to '",reg,"'",sep=""))
melted.bdat <- sqlQuery(loc,paste("select * from bdat.melted_bdat",sep=""))
melted.bdat <- melted.bdat[complete.cases(melted.bdat),]

cpt <- 0
for(i in varia){
  cpt <- cpt + 1
  melted.RAsth <- melted.bdat[melted.bdat["variable"] == i,]
  melted.RAsth[,"annees"] <- as.character(melted.RAsth[,"annees"])
  melted.RAsth[,"code_reg"] <- as.factor(melted.RAsth[,"code_reg"])
  melted.RAsth[,"nom_region"] <- as.factor(melted.RAsth[,"nom_region"])
  
  p <- ggplot(melted.RAsth) +
            geom_boxplot(aes(x=annees,y=value,col=annees))+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=nom_region,fill=nom_region),method=loess)+
            scale_x_discrete("Années")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
  
  ggsave(p,file = paste(repsortie,"boxplotbdat.png",sep=""), width = 15, height = 10)  
  }
```




```{r,highlight=TRUE,eval=FALSE}
p <- ggplot(melted.RAsth) +
            geom_boxplot(aes(x=annees,y=value,col=nom_region))+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=nom_region,fill=nom_region),method=loess)+
            scale_x_discrete("Années")+scale_y_continuous("Pourcentage")+labs(title=i)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
```



## Cartographie

Dans cette section, 

```{r,highlight=TRUE,eval=FALSE}

##Variables##
period <- c("9094","9599","0004","0509")
variable <- "corgox_med"
xlabel="Carbone organique (g/kg)"
ylabel="Fréquence"
dep <- c("17,16,86,79") # Voir pour la sélection de plusieurs département.
reg <- "54" #pour région Poitou Charentes 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'"
nclasse=5

####

# Jointure vers le fichier postgis (public.canton)
cpt <- 0
for(i in period){
  cpt <- cpt + 1
  variableBDAT <- paste(variable,i,sep="")
  print(variableBDAT)

  sqlQuery(loc,paste("alter table canton
                     drop column if exists ",variableBDAT,sep=""))
  
  sqlQuery(loc,paste("alter table canton
                      add column ",variableBDAT," numeric;
                      update public.canton
                      SET ",variableBDAT," = ",variable," from(
                      select ",variable," ,code_canton
                      from bdat.bdat_canton_",i,") as s1
                      where canton.code_canton=s1.code_canton",sep=""))
}
  
# Lecture du postgis
ogrListLayers(dsn)

mapcanton <- readOGR(dsn = dsn, "canton")

# Sélection de la zone d'étude
mapcanton <- mapcanton[mapcanton@data$code_reg==reg,]

# Classement
classe_valeur <- classIntervals(mapcanton@data[,variableBDAT],n=nclasse,style="quantile",digits=2,na.rm=TRUE)[[2]]
plot.heat(mapcanton,z=variableBDAT,breaks=classe_valeur)

}


# Représentation cartographique

cpt=0
p <- list()
for(i in period){
  cpt <- cpt + 1
  variableBDAT <- paste(variable,i,sep="")
  print(variableBDAT)

  # ggplot2
  gpclibPermit()
  carto <- fortify(mapcanton, region="id_geofla")

  # Jointure et changement de nom
  carto <- merge(carto, mapcanton@data[,c("id_geofla",variableBDAT)], by.x="id", by.y="id_geofla")
  colnames(carto)[8] <- "fill"
  
  if(cpt==1){# Classement (voir pour avoir un même code couleur pour les 4 cartes)
  classe_valeur <- classIntervals(carto[,"fill"],n=nclasse,style="quantile",digits=2,na.rm=TRUE)[[2]]
  }else{}

  # Création de la carte
  p[[i]] <- ggplot(carto, aes(x=long, y=lat)) +
            geom_polygon(data=carto, aes(group=group, fill=fill)) +
            geom_path(data=carto, aes(x=long,y=lat,group=group),color="grey30")+
            #scale_fill_distiller(palette = "Greens")+
            scale_fill_distiller(type="seq",name="Teneur en C", palette = "YlGnBu", breaks = classe_valeur)+
            guides(fill = guide_legend(reverse = TRUE))+
            #theme_bw()+
            coord_equal()+
            labs(title=i)
}

tt <- do.call(grid.arrange,p)
ggsave(tt, file = "map1.pdf", width = 16, height = 16)

```

# Test

# Analyse des facteurs explicatifs

```{r,highlight=TRUE,eval=FALSE}






```


















