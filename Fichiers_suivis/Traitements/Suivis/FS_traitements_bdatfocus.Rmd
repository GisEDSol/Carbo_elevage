---
title: "Focus des analyses de la BDAT sur plusieurs régions"
author: "Jean-Baptiste Paroissien"
date: "27/01/2017"
output:
  github_document:
    toc: true
    toc_depth: 2
    fig_width: 10
    fig_height: 10
    dev: png
    md_extensions: +autolink_bare_uris+hard_line_breaks+header_attributes+line_blocks+table_captions
---


```{r setup, include=FALSE,eval=TRUE}
# Importation des paramètres de travail
source("/media/sf_GIS_ED/Dev/Scripts/master/Fonctions/R/importparametres.R")
repmaster <- "/media/sf_GIS_ED/Dev/Scripts/master/"
importparametres(repmaster=repmaster,repdata="/media/sf_GIS_ED/Dev/",dsn="PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'")
repsortie <- paste(repmaster,"/Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers
```
```{r,eval=TRUE,echo=FALSE}
## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    
```

```{r, tidy=FALSE,eval=TRUE}
Sys.Date()
sessionInfo()
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE}
# Lecture des tables de travail
# Les tables des différences
melted.bdatdiff <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdatdiff",sep=""))
melted.bdatdiff <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdatdiff",sep=""))
melted.bdatdiff$diffmedian <- as.numeric(melted.bdatdiff$diffmedian)

# Les tables des analyses
melted.bdat <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))
dcast.bdat <- sqlQuery(loc,paste("select * from dm_vecteurs.canton",sep=""))
period <- c("9094","9599","0004","0509","1014")
melted.bdat$value <- as.numeric(melted.bdat$value)
melted.bdat <- melted.bdat[complete.cases(melted.bdat$value),]
melted.bdat$annees <- factor(melted.bdat$annees,levels=period)

# Table large
dcast.bdat_reg <- dcast.bdat[(dcast.bdat$code_reg %in% reg),]

# Régions d'intérêts
reg <- c("31","22","53","24")

dcast.bdat_reg <- sqlQuery(loc,paste("select * from dm_vecteurs.canton",sep=""))
bdat_reg <- melted.bdat[(melted.bdat$code_reg %in% reg),]
bdatdiff_reg <- melted.bdatdiff[(melted.bdatdiff$code_reg %in% reg),]
```

# Objectifs

Les travaux précédents sur l'analyse des teneurs en carbone organique ont mis en valeurs plusieurs zones intéressantes à explorer :
    - D'importantes diminution des teneurs en carbone ont été observées dans le Nord-Pas-De-Calais, Picardie et en Bretagne (surtout le Morbihan).
    - En région centre, on observe une augmentation des teneurs en C dans les départements du Loire et Cher et d'Eure et Loire (le perche). On retrouve également une augmentation ciblée dans la Marne.

# Analyse à l'échelle régionale


```{r cdf_regions,highlight=TRUE,echo=FALSE,eval=TRUE,warning=FALSE,error=FALSE,fig.height=5, fig.width=6,fig.cap = fig$cap("cdf_regions","Courbe de fréquences cumulées"),fig.align="center"}

period <- c("9094","9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
nperiod <- length(period)
colors <- brewer.pal(nperiod,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

cdf_regelevage <- ggplot(bdat_reg, aes(x=value))+
       facet_wrap(~nom_region)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Années")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_regelevage
```


# Analyse de l'évolution des teneurs en carbone organique à l'échelle nationale

A l'échelle nationale, on souhaite avoir une vision des évolutions générales des teneurs en C, appréhender les zones les plus touchées, savoir si ces évolutions sont significatives ou non.

## Analyse du nombre d'évolution significative par canton

La figure `r fig$ref("histo_evolution_reg",link=TRUE)` présente un histogramme du nombre de canton ayant connu une augmentation ou une diminution significative des teneurs en carbone organique pour les régions identifiées.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("histo_evolution_reg",""),fig.align="center"}
# Histogramme des valeurs 

# Sélection des cantons aux diminutions significatives
bdatdiff <- subset(bdatdiff_reg,diff!="Non significatif")

histo_evol <- ggplot(bdatdiff,aes(diff,fill=nom_region)) + geom_bar() +
                    scale_fill_brewer(palette = 'Paired',name="Zones d'élevage")+
                    xlab("Classe d'évolution des teneurs en carbone organique")+ylab("Nombre de canton")+
                    theme(plot.title = element_text(size = 14, face = "bold"), 
                    text = element_text(size = 12),
                    axis.title = element_text(face="bold"),
                    axis.text.x=element_text(size = 11))    
                    #geom_bar(position="dodge")
histo_evol
```
**En conclusion** de cette section, on constate plusieurs points :

## Cartographie des évolutions

Ici, production des cartes pour les régions identifiées

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,message=FALSE}

tablecarto <- "dm_vecteurs.canton" 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" 
variablecarto <- c("diff13","diff24","diff35","diff14") #variable à spatialiser
l_legend <- "Evolution des teneurs en C"#label de la variable
nclasse <- 3 #Nombre de classes de valeurs pour la cartographie
style_classe <- "fixed" #"pretty"#"jenks","fixed"
couleur <- "Spectral"#nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes

for(i in reg){
    nomfichier <- paste("Evolu_c",i,sep="")
    carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend,repsortie,nomfichier,dept=FALSE,reg=i,nrowlayout=2,ncollayout=2,position="bottom",ggsaveheight=10,ggsavewidth=10)
}

```

```{r map_carbo_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,nomfichier,sep="")
cat(paste("![](",fichiers,")",sep=""))
```

# Analyse des facteurs explicatifs

## Boxplot



```{r,eval=TRUE,echo=FALSE}

construire une table avec dcast.bdat_reg

p <- ggplot(bdatdiff_reg) +
            geom_boxplot(aes(x=diff,y=value,col=zonage_simple),notch=TRUE)+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=zonage_simple,fill=zonage_simple),method=loess)+
            #scale_color_manual(values=colors,name="Années")
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
p  
```











# Reproduire ce type de graphe par stratification

bar_prairie <- ggplot(bdatdiff_classe,aes(diff,fill=diff_var_sfp1970_2010)) + geom_bar() + facet_wrap(~ period)
bar_prairie



```{r,highlight=TRUE,eval=TRUE,fig.height=5, fig.width=8,fig.cap = fig$cap("histo_double","Histogramme à commenter"),fig.align="center"}
# On s'intéresse à la période 24
# Pour 
p1 <- ggplot(bdatdiff_reg[bdatdiff_classe$period %in% "24",],aes(diff,fill=diff_var_prairie1970_2010)) + geom_bar() + facet_wrap(~ nom_region)

p2 <- ggplot(bdatdiff_classe[bdatdiff_classe$period %in% "24",],aes(diff,fill=diff_var_sfp1970_2010)) + geom_bar() + facet_wrap(~ nom_region)

# Ici, regarder les prairies et la sfp, il y a une relation entre ces deux variables. Certes, les prairies ont chuté en Bretagne, mais les modes de production ont évolués et ont laissé place à la stabulation. Les sfp ont augmentée...
p.ass <- grid.arrange(p1,p2,ncol=2)
```

# Analyse sur les régions d'élevage B, C et D

## Histogrammes
```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE}
# Histogramme des valeurs 
periodetud <- c("14","24","15","25")
# Sélection des cantons aux diminutions significatives et des zones B,C et D
bdatdiff <- subset(melted.bdatdiff,diff!="Non significatif")
bdatdiffBCD <- bdatdiff[(bdatdiff$period %in% periodetud) & bdatdiff$zonage_simple %in% c("B","C","D"), ]

# Sélection
bdatdiff$diff <- as.factor(bdatdiff$diff)
ggplot(bdatdiffBCD,aes(diff,fill=zonage_simple)) + geom_bar(position="dodge") + facet_wrap(~period)

```

## Graphiques de correlation
Rajouter les droites de régressions 
Rajouter les variation climatiques + l'occupation du sol

Figure ci-dessous à commenter pour aller plus loin.

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE}
# GET EQUATION AND R-SQUARED AS STRING
# SOURCE: http://goo.gl/K4yh


x <- "hpluie_an"
y <- "corgox_medequi9094"

lm_eqn <- function(df,x,y){
    m <- lm(x ~ y, df);
    eq <- substitute(italic(x) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(coef(m)[1], digits = 2), 
              b = format(coef(m)[2], digits = 2), 
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));                 
}

# Stratifier les plots par les régions et autres facteurs (voir pour la classification climatique)
ggplot(dcast.bdat, aes(hpluie_an, corgox_medequi9094,shape=factor(classe_p_prairie2000))) +
  geom_point(aes(colour = factor(classe_p_prairie2000)), size = 3) +
  geom_point(colour="grey10", size = 1.5) + geom_smooth(method='lm',formula=y~x) #+ facet_wrap(~ zonage_cplt) + 


geom_text(data=eq,aes(x = 25, y = 300,label=V1), parse = TRUE, inherit.aes=FALSE)



ggplot(dcast.bdat, aes(hpluie_an, corgox_medequi9094)) +
  geom_point(aes(colour = factor(classe_p_prairie2000)), size = 3) +
  geom_smooth(method='lm',formula=y~x) #+ facet_wrap(~ zonage_cplt) + 


geom_smooth(method = "lm", se = FALSE)







# Voir un peu plus G1 (bof, peut d'intérêt. Eventuellement, voir pour une figure synthétique avec une matrice présentant les coef de correlation)
#ggplot(dcast.bdat[dcast.bdat$zonage_cplt %in% "G1",], aes(hpluie_an, corgox_medequi9094,shape=factor(classe_p_prairie2000))) +
 # geom_point(aes(colour = factor(classe_p_prairie2000)), size = 4) +
  #geom_point(colour="grey10", size = 1.5)
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE}
# Plot of the change in the cantonal medians of soil OC versus the cantonal medians of soil OC content averaged over the two extreme periods (1990–1994 and 2000–2004). Triangles are significant changes. Circles are non-significant changes. Line is the regression (r 2 = 0.15) between the change in the cantonal medians of soil OC and the cantonal medians of soil OC averaged over the two extreme periods.

# Ici, on reprend la figure 7 de Saby2008

dcast.bdat$meancorgox9599_0409 <- rowMeans(cbind(dcast.bdat$corgox_medequi9599,dcast.bdat$corgox_medequi0409),na.rm=TRUE)
ggplot(dcast.bdat, aes(meancorgox9599_0409,diffmedian24,shape=factor(diff24))) +
  geom_point(aes(colour = factor(diff24)), size = 4) +
  geom_point(colour="grey10", size = 1.5) + facet_wrap(~ zonage_cplt)

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE}
#Median of baseline soil OC content (first period) versus change in median of soil OC values over the whole survey. Triangles are significant changes. Circles are non-significant changes. Line is the regression (r 2 = 0.24) between median of baseline SOC (1990–1994) and significant changes

# Ici, on reprend la figure 5 de Saby2008
# Revoir ces figures, problème avec les données
dcast.bdat$meancorgox9599_0509 <- rowMeans(cbind(dcast.bdat$corgox_medequi9599,dcast.bdat$corgox_medequi0509),na.rm=TRUE)

ggplot(dcast.bdat, aes(meancorgox9599_0409,diffmedian24,shape=factor(diff24))) +
  geom_point(aes(colour = factor(diff24)), size = 4) +
  geom_point(colour="grey10", size = 1.5)# + facet_wrap(~ zonage_cplt)


ggplot(dcast.bdat, aes(altimean,meancorgox9599_0509)) +
  geom_point(aes(colour = factor(diff24)), size = 4) +
  geom_point(colour="grey10", size = 1.5)# + facet_wrap(~ zonage_cplt)



```



```{r,eval=FALSE}
# Voir le développement de ce type de graphique
dcast.bdatBCD <- dcast.bdat[dcast.bdat$zonage_simple %in% c("B","C","D"),]

ggplot(dcast.bdatBCD, aes(var_ugb8810, diffmedian15,shape=factor(diff15))) +
  geom_point(aes(colour = factor(diff15)), size = 2) +
  geom_point(colour="grey10", size = 1.5)


ggplot(dcast.bdatBCD, aes(var_sth1970_2010, diffmedian15,shape=factor(diff15))) +
  geom_point(aes(colour = factor(diff15)), size = 2) +
  geom_point(colour="grey10", size = 1.5)


ggplot(melted.bdatdiff, aes(var_cereale1970_2010, diffmedian15,shape=factor(diff15))) +
  geom_point(aes(colour = factor(diff15)), size = 2) +
  geom_point(colour="grey10", size = 1.5)
```
# Analyse avec une ACP


```{r,highlight=TRUE,eval=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("acp_evolution_fr","Classification de l'importance des variables explicatives par classes de région d'élevage après une modélisation par arbres de régressions boostés"),fig.align="center"}

########################
Rcovarclimato <- c("std_temp_janv","std_temp_juil","std_pluie_janv","std_pluie_juil")
typeclimato <- replicate(length(Rcovarclimato), "climat")
#
Rcovaroccup <- c("var_sth1970_2010","var_sth1979_2010","var_sth1988_2010","var_c1970_2010","var_c1979_2010","var_c1988_2010","var_sfp1970_2010","var_sfp1979_2010","var_sfp1988_2010","var_mf1970_2010","var_mf1979_2010","var_mf1988_2010","var_prairie1970_2010","var_prairie1979_2010","var_prairie1988_2010","var_ugb1988_2010")
typeoccup <- replicate(length(Rcovaroccup), "occup")

type <- c(typeclimato,typeoccup)
Rcovar <- c(Rcovarclimato,Rcovaroccup,"diff24")
vNames <- c("diffmedian24",Rcovar) #9599 car meilleure représentation spatiale
########################

# Lecture de la table sans les NA
lvNames <- length(vNames)
dcast.bdat_variables <- dcast.bdat[complete.cases(dcast.bdat[,vNames]),]

res.pca <- PCA(dcast.bdat_variables[,!names(dcast.bdat_variables) %in% "diff24"], graph = FALSE)
#fviz_screeplot(res.pca, ncp=10)

pca <- fviz_pca_var(res.pca, axes = c(1,2),col.var="contrib") +
scale_color_gradient2(low="white", mid="blue", 
                  high="red", midpoint=50) + theme_minimal()
pca

fviz_pca_biplot(res.pca, label="var",habillage=dcast.bdat_variables$diff24,axes=c(1,2),
     addEllipses=FALSE, ellipse.level=0.95, ggtheme = theme_minimal())
```


# Modélisation de l'évolution des teneurs ?

```{r,highlight=TRUE,eval=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("gbm_evolution_fr","Classification de l'importance des variables explicatives par classes de région d'élevage après une modélisation par arbres de régressions boostés"),fig.align="center"}

######################
Rcovarclimato <- c("std_temp_janv","std_temp_juil","std_pluie_janv","std_pluie_juil")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovaroccup <- c("var_sth1970_2010","var_sth1979_2010","var_sth1988_2010","var_c1970_2010","var_c1979_2010","var_c1988_2010","var_sfp1970_2010","var_sfp1979_2010","var_sfp1988_2010","var_mf1970_2010","var_mf1979_2010","var_mf1988_2010","var_prairie1970_2010","var_prairie1979_2010","var_prairie1988_2010","var_ugb1988_2010")
typeoccup <- replicate(length(Rcovaroccup), "occup")

type <- c(typeclimato,typeoccup)
Rcovar <- c(Rcovarclimato,Rcovaroccup)
vNames <- c("diffmedian24",Rcovar) #9599 car meilleure représentation spatiale
######################

# Sélection du jeu de données
id <- "id_geofla"# Nom du champs présentant un identifiant unique
dcast.bdat_gbm <- dcast.bdat[complete.cases(dcast.bdat[,vNames]),c(vNames,id)] # Pour supprimer les NA
datax <- dcast.bdat_gbm[, vNames[-1]]
datay <- dcast.bdat_gbm[, vNames[1]]

tuneGrid <- expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:20)*150,shrinkage = 0.1,n.minobsinnode = 20)
trControl <- trainControl(method = "cv",p=0.8)

#registerDoMC(4) # Nombre de processeurs activés
#mgbm <- train(x = datax , y = datay,method="gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)
#plot(varImp(mgbm), top = 10)

set.seed(157)#Pour assurer la reproductibilité
nbl <- 2
prob <- 0.8
model <- "gbm"

# Pour le stockage des résultats
rest <- array(NA, dim = c(length(datay), nbl, 1),list(id = dcast.bdat_gbm[,id], loop = 1:nbl, mod = model))
  
for (j in 1:nbl){
  gc()  
  # randomizes the mask 
  print(j)
  masko <- createDataPartition(dcast.bdat_gbm[,1],p = prob, list = FALSE)
  
  donneeL <- dcast.bdat_gbm[masko,]
  donneeV <- dcast.bdat_gbm[-masko,]
  learningx <- datax[masko,]
  learningy <- datay[masko]
  indepx <- datax[-masko,]
  indepy <- datay[-masko]

  mgbm <- train(x = learningx , y = learningy,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)
  #best.iter <- gbm.perf(mgbm,method="cv")
  #save(mgbm,file=paste(fold,"mfinal",titre,"_",model,"_",j,".RData",sep=""))
                  
  f.predict <- predict(mgbm$finalModel, learningx , n.trees = mgbm$bestTune$n.trees)
  #save(f.predict,file=paste("fpredict",titre,"_",model,".RData",sep=""))

  indep.pred <- predict(mgbm$finalModel, indepx , n.trees=mgbm$bestTune$n.trees)

  # Si transformation log du c        
  #indep.pred <- exp(indep.pred)
        
  rest[-masko, j, model] <- indep.pred  
  residue <- learningy - f.predict
  donneeL$residues <- residue
        
  # Construire la moyenne des résidus dans un dataframe!
  write.csv(donneeL,paste(repsortie,"donneeL",model,"_",j,".csv",sep=""))  
}

#Calcul de la moyenne des résidus
restResidues <- array(NA, dim = c(nrow(donneeL),nbl,2),list(idresidues = seq(1,nrow(donneeL),1),loop=1:nbl,data=c("residues","idresidues")))

for(i in 1:nbl){
  print(i)
  donnee <- read.csv(paste(repsortie,"donneeL",model,"_",i,".csv",sep=""))

  #donnee <- donnee[with(donnee, order(id)),]# revoir ce point

  residues <- donnee$residues
  id <- donnee$id
  restResidues[,i,"residues"] <- residues
  restResidues[,i,"idresidues"] <- id
}
restResidues <- as.data.frame(restResidues)

dfcomplet <- as.data.frame(pt@data["id"][with(pt@data["id"],order(id)),])
colnames(dfcomplet) <- "id"

# Revoir...      
dfcomplet <- as.data.frame(dcast.bdat_gbm[id][with(dcast.bdat_gbm[id],order(id)),])
colnames(dfcomplet) <- "id"

restMeanResidues <- array(NA, dim = c(nrow(pt),nbl+1),list(id=1:nrow(pt@data["id"]),data=c("idresidues",paste(1:nbl,".residues",sep=""))))

for(i in 1:nbl){
  print(i)
  dtmerge <- merge(restResidues[c(paste(i,".residues",sep=""),paste(i,".idresidues",sep=""))],dfcomplet,by.x=paste(i,".idresidues",sep=""),by.y="id",all=TRUE)
  restMeanResidues[,paste(i,".residues",sep="")] <- dtmerge[[2]]
}

restMeanResidues[,"idresidues"] <- dfcomplet[["id"]]
dfMeanResidues <- as.data.frame(restMeanResidues)
dfMeanResidues <- rowMeans(dfMeanResidues,na.rm=TRUE)
##>> export!

rest <- cbind(as.data.frame(rest),pt@data[vNames[1]])

```


# Modélisation spatio-temporelle

Regarder :

multivariate regression-kriging and generalized linear models par Nickel2014;
et generalized least squares regression par Begueria2013.

```{r,highlight=TRUE,eval=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("glm_evolution_fr","Classification de l'importance des variables explicatives par classes de région d'élevage après une modélisation par arbres de régressions boostés"),fig.align="center"}

# Logistic Regression
# where F is a binary factor and
# x1-x3 are continuous predictors
fit <- glm(F~x1+x2+x3,data=mydata,family=binomial())
summary(fit) # display results
confint(fit) # 95% CI for the coefficients
exp(coef(fit)) # exponentiated coefficients
exp(confint(fit)) # 95% CI for exponentiated coefficients
predict(fit, type="response") # predicted values
residuals(fit, type="deviance") # residuals 

```

