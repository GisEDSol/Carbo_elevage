---
title: "Analyse des teneurs en carbone organique de la BDAT"
author: "Jean-Baptiste Paroissien"
date: "31/01/2017"
output:
  github_document:
    toc: true
    toc_depth: 2
    fig_width: 10
    fig_height: 10
    dev: png
    md_extensions: +autolink_bare_uris+hard_line_breaks+header_attributes+line_blocks+table_captions
---

```{r setup, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
# Importation des paramètres de travail
source("/media/sf_GIS_ED/Dev/Scripts/master/Fonctions/R/importparametres.R")
repmaster <- "/media/sf_GIS_ED/Dev/Scripts/master/"
importparametres(repmaster=repmaster,repdata="/media/sf_GIS_ED/Dev/Data/",dsn="PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'")
repsortie <- paste(repmaster,"Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers
```

```{r,eval=TRUE,echo=FALSE}
## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    
```

```{r date, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
date <- Sys.Date()
sessionInfo()
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Lecture des tables de travail
melted.bdat <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))
dcast.bdat <- sqlQuery(loc,paste("select * from dm_vecteurs.canton",sep=""))
period <- c("9094","9599","0004","0509","1014")
melted.bdat$value <- as.numeric(melted.bdat$value)
melted.bdat <- melted.bdat[complete.cases(melted.bdat$value),]
melted.bdat$annees <- factor(melted.bdat$annees,levels=period)


# Option2 Nettoyage : Sélection d'un jeu de données où le nombre de canton est constant d'une période à une autre (pour éviter les biais entre les périodes)
bdat.cplt <- sqlQuery(loc,paste("select * from dm_vecteurs.canton_cplt",sep=""))
melted.cplt <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat_cplt",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))

# 9514
bdat9514 <- sqlQuery(loc,paste("select * from dm_vecteurs.canton_9514",sep=""))
melted.9514 <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat_9514",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))
melted.9514$value <- as.numeric(melted.9514$value)
melted.9514 <- melted.9514[complete.cases(melted.9514$value),]
melted.9514$annees <- factor(melted.9514$annees,levels=c("9599","0004","0509","1014"))
```

# Objectifs

Dans ce fichier, les analyses cantonales de la BDAT sont analysées afin appréhender la distribution statistique et géographique des teneurs en carbone organique regroupées en 5 périodes : 1990-1994, 1995-1999, 2000-2004, 2005-2009 et 2010-2014. Les résultats présentés font suite à différents scripts de préparations de données dont la chaîne de traitements générale est consultable à cette [adresse](`r github_url`Documentation/Modes_operatoires/Figures/workflow.html)

Globalement, le travail est organisé de la manière suivante :

- **Statistiques descriptives** : Analyse des histogrammes de fréquence et tests statistiques pour chacune des périodes de temps analysées,
- **Représentation cartographique** : Plusieurs cartes sont proposées pour visualiser la répartition géographiques des données
- **Analyse des facteurs explicatifs** : Analyse des facteurs explicatifs. 

# Analyse des teneurs en carbone organique par période

Cette première étape a pour but d'analyser les différences des teneurs en carbone organique pour chacune des périodes de temps analysées. Celles-ci comportent les années 1990-1994;1995-1999;2000-2004;2005-2009 et 2010-2014. Les statistiques descriptives et les courbes de fréquences cumulées sont présentées dans un premier temps. Dans un second temps, des boxplots accompagnés de tests de « significacité » des différences entre les périodes sont mis en oeuvre. Au cours de ces travaux, le regard est porté sur l'emprise nationale mais avec plusieurs niveaux de stratification (régions administratives, zonages climatiques, principales région d'élevage).

## Analyse à l'échelle de la France

Important, dans l'analyse spatiale des teneurs en carbone organique, rajouter le nombre d'effectif...celà permettra de rajouter 

### Statistiques descriptives

La figure `r fig$ref("cdf_fr",link=TRUE)` présente les courbes de fréquences cumulées des teneurs en carbone organique distribuées pour les 5 périodes. Les courbes de fréquences des 5 périodes présentent la même forme en "S" et s'individualisent juste avant le plateau, présentant une différence affectant les sols riches en teneurs organiques (entre 17 et 45 g/kg). Sur cette zone (figure à droite), la figure montre un décalage des courbes des périodes 2000-2004, 2005-2009 et 2010-2014 vers des valeurs plus faibles. Parmi ces 3 périodes, la période 2005-2009 est celle qui se décale le plus vers des teneurs plus faible tandis que la période 2010-2014 se rapproche des valeurs de 1990-1994 et 1995-1999, présentant ainsi une inversion de la tendance observée. Ces trois périodes se distinguent clairement des périodes de 1990-1994 et 1995-1999 qui sont rapprochées.

**Ces observations mettent en évidence une diminution des teneurs en carbone entre les périodes 1990-1999 et 2000-2009 et une légère augmentation pour la période 2010-2014.**

```{r cdf_fr,highlight=TRUE,echo=FALSE,eval=TRUE,warning=FALSE,error=FALSE,fig.height=5, fig.width=7,fig.cap = fig$cap("cdf_fr","Courbe de fréquences cumulées"),fig.align="center"}

melted.bdat <- melted.9514

#Problème avec l'ouverture de la table
period <- c("9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
nperiod <- length(period)
colors <- brewer.pal(nperiod,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

p <- list()
# Courbe de fréquence cumulée
p[[1]] <- ggplot(melted.bdat, aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))

ggsave(p[[1]],file = paste(repsortie,"cdf_fr1.png",sep=""), width = 9, height = 7)  


p[[2]] <- ggplot(melted.bdat[(melted.bdat$value > 17) & (melted.bdat$value < 45) ,], aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))

ggsave(p[[2]],file = paste(repsortie,"cdf_fr2.png",sep=""), width = 9, height = 7)  


tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))

ggsave(tt,file = paste(repsortie,"cdf_fr.png",sep=""), width = 10, height = 7)  
```

```{r summarybdatfrance,echo=FALSE,eval=TRUE}
# Résumé des statistiques 
bdatsummary <- apply(melted.bdat["value"],2, function(x) tapply(x, melted.bdat[,"annees"],summary))
bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
```
La distribution des teneurs en carbone organique par période est présentée dans la figure `r fig$ref("boxplot_fr",link=TRUE)` et les principales statistiques sont présentées dans le tableau ci-dessus. La tendance de diminution des teneurs observée dans la figure `r fig$ref("cdf_fr",link=TRUE)` est également constatée dans ces deux éléments. La période 2000-2004 montre la valeur médiane la plus faible avec une valeur de `r bdatsummary$value["0004","Median"]` g/kg. Les valeurs les plus importantes sont observées pour les périodes 1990-1994 et 1995-1999 avec respectivement des teneurs en carbone organique de `r bdatsummary$value["9094","Median"]` et `r bdatsummary$value["9599","Median"]`. En terme de tendance, on remarque une augmentation des teneurs pour la période 2010-2014 avec une médiane des valeurs de `r bdatsummary$value["1014","Median"]`. Ces évolutions sont très légèrement marquées sur la figure `r fig$ref("boxplot_fr",link=TRUE)` où l'évolution moyenne des teneurs en carbone organique baisse légèrement après la période 1995-1999.

```{r summarybdatfrancetable,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis'}
pander(bdatsummary[[1]],caption = "Statistiques descriptives des teneurs en carbone organique pour les différentes périodes")
```

```{r boxplot_fr,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=5, fig.width=6,fig.cap = fig$cap("boxplot_fr","Boxplot des teneurs en carbone organiques par périodes"),fig.align="center"}

p <- ggplot(melted.bdat, aes(x=annees,y=value)) + 
  #geom_violin(trim=FALSE)+
  #geom_boxplot(width=0.1, fill="white")+
  geom_boxplot()+
  #scale_color_manual(values=colors,name="Années")+
  geom_smooth(method = "loess", se=FALSE, color="black", aes(group=1))+
  scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone organique (g/kg)")+
  theme(plot.title = element_text(size = 14, face = "bold"), 
        text = element_text(size = 12),
        axis.title = element_text(face="bold"),
        axis.text.x=element_text(size = 11))

p
ggsave(p,file = paste(repsortie,"boxplotbdat.png",sep=""), width = 5, height = 6)  
```

Les résultats du test de Wilcoxon présentés ci-dessous montrent que **les différences globales entre les périodes sont significatives pour [1990-1994 et 2000-2004], [1995-1999 et 2000-2004], [1995-1999 et 2005-2009] et [2000-2004 et 2010-2014]**. Ces résulats sont à prendre avec mesure, car réalisés sur l'ensemble des cantons. Ils confirment néanmoins les tendances observées sur les courbes de fréquences cumulées (voir figure `r fig$ref("cdf_fr",link=TRUE)`).

```{r,highlight=TRUE,eval=TRUE,echo=TRUE}
pairwise.wilcox.test(melted.bdat[,"value"], melted.bdat[,"annees"])
```

### Cartographie des teneurs en carbone organique

Bien que l'hétérogénéité spatiale et temporelle des analyses de la BDAT soient assez importante (certaines zones souffrent d'un manque de données), la cartographie des teneurs en carbone organique (ci-dessous) montre une distribution spatiale organisée et globalement similaire pour les différentes périodes analysées. De façon générale, cette organisation suit la lithologie du pays avec de fortes teneurs en carbone organique présentes dans les zones de socles et de piemonds et des valeurs plus faibles dans les principaux bassins sédimentaires (parisien et aquitain).

La section suivante s'attache à analyser la distribution spatiale des teneurs en carbone organique pour comprendre par la suite les leviers agissant sur les évolutions des teneurs.

```{r carto_c_fr,highlight=TRUE,eval=FALSE,echo=FALSE}
# Paramètres #################
tablecarto <- "dm_vecteurs.canton_9514" #Nom de la table utilisée pour la cartographie (table postgis)
#period <- c("9094","9599","0004","0509","1014") #
period <- c("9599","0004","0509","1014") #
variable <- "corgox_medequi"
variablecarto <- paste(variable,period,sep="")#variables à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- "YlOrRd" #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Teneur en carbone organique (g/kg)" #label de la variable
nomfichier <- "corgoxmed_period_fr_9514" #Nom du fichier

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=2,position="bottom",ggsaveheight=7,ggsavewidth=7)

variable <- "eff"
period <- c("9094","9599","0004","0509","1014") #
variablecarto <- paste(variable,period,sep="")#variables à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- "YlOrRd" #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Nombre d'échantillon par canton" #label de la variable
nomfichier <- "effectif_bdat_cplt" #Nom du fichier

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=3,position="bottom",ggsaveheight=7,ggsavewidth=9.2)
```

```{r map_carbo_fr, echo = F, results = 'asis'}
# Pour insérer l'image
nomfichier <- c("corgoxmed_period_fr.png","effectif_bdat.png")
fichiers <- paste(repsortie,nomfichier,sep="")
cat(paste("![](",fichiers,")",sep=""))
```

## Analyse des facteurs contrôlant la distribution spatiale

Dans cette partie, les facteurs contrôlant la distribution spatiale des teneurs en carbone organique des différentes périodes sont analysés. Le travail est dans un premier porté par une analyse en composante principale pour identifier les relations entre les facteurs potentiellement explicatif et dans un deuxième temps par une modélisation avec la méthode des arbres de régression boostés pour affiner l'analyser et classer les variables explicatives par ordre d'importance (contribution).

### Analyse en composante principale

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Sélection du jeu de données
dcast.bdat <- bdat9514

# Sélection des variables de travail
Rcovarclimato <- c("hpluie_an","jchauds_an","jfroids_an","ttemp_an","pluie_ecart_janv","pluie_ecart_juil","ampli_t_juil_janv","jpluie_janv","jpluie_juil")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- "argi_med"
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rcovaroccup <- c("p_sfp1988","elevage1988","grdcultures1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_c1988","p_c1970","p_c1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","p_cop1970","p_cop1979","p_cop1988")
typeoccup <- replicate(length(Rcovaroccup), "occup")

type <- c(typeclimato,typetopo,typeoccup)
Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Rcovaroccup,"classe_C")
vNames <- c("corgox_medequi9599",Rcovar)

# Lecture de la table sans les NA
lvNames <- length(vNames)
dcast.bdat_variables <- dcast.bdat[complete.cases(dcast.bdat[,vNames[-lvNames]]),vNames[-lvNames]]

# Création d'une classe de valeur pour le carbone
classe_valeur <- classIntervals(dcast.bdat_variables[vNames[1]][[1]],n=4,style="quantile",digits=1,na.rm=TRUE)[[2]]
dcast.bdat_variables[,"classe_C"] <- cut(dcast.bdat_variables[vNames[1]][[1]],breaks = data.frame(classe_valeur)[,1],include.lowest=T) 

res.pca <- PCA(dcast.bdat_variables[,!names(dcast.bdat_variables) %in% "classe_C"], quanti.sup=1,graph = FALSE)# Mettre le carbone en illustratif (quanti.sup=num de colonne)
#fviz_screeplot(res.pca, ncp=10)

for(i in c(10,25,50)){
pca <- fviz_pca_var(res.pca, axes = c(1,2),col.var="contrib",select.var = list(contrib = 10)) +
scale_color_gradient2(low="white", mid="blue", 
                  high="red", midpoint=50) + theme_minimal()
ggsave(pca,file = paste(repsortie,"pca_12_",i,".jpg",sep=""), width = 8, height = 8)  
}

#
pca <- fviz_pca_var(res.pca, axes = c(1,3),col.var="contrib") +
scale_color_gradient2(low="white", mid="blue", 
                  high="red", midpoint=50) + theme_minimal()

ggsave(pca,file = paste(repsortie,"pca_10.png",sep=""), width = 8, height = 8)  


```
La figure `r fig$ref("pca_fr",link=TRUE)` présente la distribution des variables sur les axes 1 et 2 de l'ACP. Environ `r round(res.pca$eig[1,2]+res.pca$eig[2,2])` pourcent de l'information est contenu dans ces deux premiers axes. Description de la distribution des variables dans l'espace des ACP : 

- L'axe 1 représente `r round(res.pca$eig[1,2])`% de l'information. Cet axe est fortement associé à l'occupation du sol. Les différentes variables associées aux grandes cultures et à l'élevage sont bien représentées et ont une forte contribution dans la variance du jeu de données. Les statistiques liées à la part d'STH, de prairies, de SFP et d'OTEX polyculture élevage sont corrélées et sont opposées aux variables associées aux grandes cultures (proportion des surfaces de céréales/SAU et OTEX grandes cultures). 
- L'axe 2 représente `r round(res.pca$eig[2,2])`% de l'information. La correlation avec les variables est moins nette que l'axe 1. Les variables de type climat et topographie sont légèrement correlées à cet axe. D'autres variables d'occupation du sol sont associées à l'axe 2. Celles-ci concernent les zones agricoles hétérogènes ($clc_25_90$), les zones de maïs fourrage et les zones qui ont une densité importante en UGBTA. Logiquement, ces deux dernière variables sont liées.

- Plusieurs variables ont un faible impact et seront écartées par la suite :
  - Pour l'occupation du sol : les variables liées à Corine Land Cover
  - Pour le climat : *jpluie_juillet*, *ttemp_an*, *jchauds_an (voir peut être aussi hpluie_an)*

Dans cet espace, la teneur en carbone organique initiale (période 90-94) est moyennement représentée (-50% de contribution). Cette variable est directement opposée aux variables climatiques ce qui met en valeur l'importance de ce facteur dans la distribution spatiale des teneurs à l'échelle de la France.
Dans une moindre mesure, la teneur en CO est correlée aux surfaces fourragères principales et aux UGBTA.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=8,fig.cap = fig$cap("pca_fr",""),fig.align="center"}
pca
# revoir cette discussion sur l'intérêt de la PCA pour la sélection des variables. A titre de conclusion, c'est assez intéressant.http://stats.stackexchange.com/questions/27300/using-principal-component-analysis-pca-for-feature-selection
```
Dans la figure `r fig$ref("pcabiplot_fr",link=TRUE)`, les échantillons sont rajoutés dans l'espace de correlation des variables. La représentation des échantillons classés par teneurs en carbone organique permet de visualiser le lien entre les variables et ...(mal dit).

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("pcabiplot_fr",""),fig.align="center"}
pca_biplot <- fviz_pca_biplot(res.pca, label="var",habillage=dcast.bdat_variables$classe_C,
     addEllipses=TRUE, ellipse.level=0.95, ggtheme = theme_minimal())
ggsave(pca_biplot,file = paste(repsortie,"pca_biplotellipse.jpg",sep=""), width = 8, height = 8)  


```

### Modélisation avec GBM

Bien spécifier que GBM est utilisé juste pour appréhender l'importance et le comportement des variables explicatives.

L'application de ces modèles demande une bonne configuration de leurs paramètres. Pour déterminer la meilleur combinaison de paramètres, la fonction *train* du package *caret* est utilisée.

1. Boosted regression tree (BRT)
Les modèles d'arbres de régression boostés sont connus pour améliorer la précision de prédiction par rapport aux simples arbres de régression.
L'algo permet d'ajuster un modèle en fonction d'un processus itératif. A chaque itération, les arbres de régresssions sont ajustés et montés sur une fraction de l'ensemble des données échantillongées. Les principaux paramètres d'un modèle sont :
	1. le taux d'apprentissage *(skrinkage)* : il correspond à une constante déterminant l'influence de la combinaison individuelle des arbres qui forme le forme le modèle final. Lorsque ce coefficient est faible, le modèle est très spécialisé et est difficilement applicable sur un autre jeu de données.
	2. la taille des arbres *(interaction depth)* correspond à la taille des arbres de régression. Lorsque la taille est égale à 1, chaque arbre est constitué d'un seul noeud, on modélise l'effet d'une seule variable prédictive. Ainsi, le modèle final additionne séparément l'effet prédictif des variables et les intéractions des variables ne sont pas explicitement prise en compte. Lorsque la taille des arbres est supérieur à 1, chaque arbre de régression individuelle modélise l'interaction d'au moins deux variables prédictives. Celà permet l'utilisation de modèle prenant en compte les intéractions d'ordre i entre les variables prédictives. La capacité de représenter les interactions entre les variables prédictives sans connaissance a priori est l'un des avantages  des arbres de régression.
	3. le nombre d'arbre *(n.tree)*correspond au nombre d'arbre pour l'ajustement. C'est l'équivalent du nombre d'itérations.

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}
##### Sélection des variables explicatives (revoir cette sélection, se baser sur un tableau à charger en fonction des périodes à analyser)
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","ampli_t_juil_janv","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- "argi_med"
typepedo <- replicate(length(Rcovartopo), "pedologie")

Rcovaroccup <- c("p_sfp1988","grdcultures1988","elevagehorsol1988","polyelevage1988","elevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_c1988","p_c1970","p_c1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","ugbta1988","p_cop1970","p_cop1979","p_cop1988","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90")
typeoccup <- replicate(length(Rcovaroccup), "occup")

type <- c(typetopo,typepedo,typeoccup,typeclimato)
Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)
vNames <- c("corgox_medequi9599",Rcovar) #9599 car meilleure représentation spatiale, il faudra mieux justifier l'étude de cette variable
#####################

# Sélection du jeu de données
id <- "id_geofla"# Nom du champs présentant un identifiant unique
dcast.bdat <- bdat9514
d <- dcast.bdat[,c(vNames,id)]
d <- d[complete.cases(vNames),]


# Log
#d[vNames[1]] <- log(d[vNames[1]])

# Identification des meilleurs paramètres de modélisation

trainrows <- runif(nrow(d)) > 0.2
train <- d[trainrows,] #Données pour l'apprentissage
test <- d[!trainrows,] #Données pour test

set.seed(157) #Pour assurer la reproductibilité
registerDoMC(4)
#formula <- as.formula(paste(vNames[1],"~",paste(vNames[-1],collapse="+"),sep=""))
trControl <- trainControl(method = "cv",p=0.8,number=100)
tuneGrid <- expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10)

##
datax <- d[, vNames[-1]]
datay <- d[, vNames[1]]

# Utilisation de caret, car plus rapide qu'une simple fonction gbm
mgbm <- train(x = datax , y = datay,method="gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)
##

#mgbm_fr <- train(formula,data=train,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T,na.action = na.omit)

save(mgbm,file=paste(repsortie,"mgbm_fr1302.RData",sep=""))
load(paste(repsortie,"mgbm_fr1302.RData",sep=""))
# Maintenant, on lancer le code x fois avec les paramètres de modélisation optimisé
# Calcul de la moyenne de l'importance + du résultat de prédiction (30% du jeu de données indépendant)
trControl <- trainControl(method = "cv",p=0.8,number=10)
tuneGrid <- expand.grid(interaction.depth = mgbm$bestTune$interaction.depth,n.trees = mgbm$bestTune$n.trees,shrinkage = 0.1,n.minobsinnode = 10)


nbr <- 50
prob <- 0.8
rest <- array(NA, dim = c(nbr, 3),list(loop = 1:nbr, mod = c("r2","MSE","RMSE")))
importVar <- array(NA, dim = c(length(vNames)-1,nbr+1))
pvar <- list()

cpt <- 0
for (i in 1:nbr){
  cpt <- cpt + 1
  print(i)
  set.seed(157+i)
  gc()  
  # randomizes the mask 
  masko <- createDataPartition(d[,1],p = prob, list = FALSE)
  
  donneeL <- d[masko,]
  donneeV <- d[-masko,]
  learningx <- datax[masko,]
  learningy <- datay[masko]
  indepx <- datax[-masko,]
  indepy <- datay[-masko]

 #train <- d[masko,] #Données pour l'apprentissage
 #test <- d[-masko,] #Données pour test

  mgbm <- train(x = learningx , y = learningy,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)

#  mgbm <- train(formula,data=train,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T,na.action = na.omit)
 
  pvar[[i]] <- varImp(mgbm)
  
  vaript <- summary(mgbm,plotit=FALSE)
  vaript <- vaript[order(vaript$var),]
  importVar[,1] <- as.character(vaript$var)
  importVar[,cpt] <- as.numeric(vaript$rel.inf)

  f.predict <- predict(mgbm$finalModel, learningx , n.trees = mgbm$bestTune$n.trees)
  
  ### External validation on independent data ###   
  indep.pred <- predict(mgbm$finalModel, indepx , n.trees=mgbm$bestTune$n.trees)

  rest[i,"r2"] <- round(cor(indep.pred,indepy,use="na.or.complete")^2,4)
  rest[i,"MSE"] <- mean((indep.pred-indepy)^2,na.rm=TRUE)
  rest[i,"RMSE"] <- mean((indep.pred-indepy)^2,na.rm=TRUE)^0.5
}

summary(rest)

save(rest,file=paste(repsortie,"rest.RData",sep=""))
save(importVar,file=paste(repsortie,"importVar.RData",sep=""))

datapred <- as.data.frame(cbind(indep.pred,indepy))

p_corel_fr <- ggplot(datapred, aes(indep.pred,indepy)) +
            geom_point(alpha = 0.8, size = 2) +
            scale_x_continuous("Teneur en carbone prédite (g/kg)")+scale_y_continuous("Teneur en carbone observée (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=20, y=50, label=lm_eqn(lm(datapred[,"indep.pred"]~datapred[,"indepy"], datapred)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    

ggsave(p_corel_fr,file = paste(repsortie,"corel_fr.jpg",sep=""), width = 8, height = 8)  


varimp <- as.data.frame(importVar[,-1])

n <- 0
for(i in 1:nbr){
    n <- n + 1
    varimp[,n] <- as.numeric(varimp[,n])
}

MeanimportVar <- apply(varimp, 1, function(x){median(x,na.rm=TRUE)}) 

#MeanimportVar <- rowMeans(varimp,na.rm=TRUE)           
MeanimportVar <- cbind.data.frame(importVar[,1],MeanimportVar)
colnames(MeanimportVar) <- c("variable","importance")

MeanimportVar <- MeanimportVar[with(MeanimportVar, order(-importance)),]
varimport <- MeanimportVar[1:15,]
varimport$variable <- reorder(varimport$variable, varimport$importance)

varimport$type <- varimport$variable
varimport$type <- gsub2(as.character(Rcovar),type,as.character(varimport$variable))#Ajout du type de facteurs

pimp <- ggplot(varimport, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(stat = "identity") + coord_flip()

save(pimp,file=paste(repsortie,"p_mgbm_classeC.RData",sep=""))

ggsave(pimp,file = paste(repsortie,"pimp.jpg",sep=""), width = 8, height = 8)  

```
Les principales variables explicatives de la distribution des teneurs en carbone organique sont présentées figure `r fig$ref("gbm_fr",link=TRUE)`. Les facteurs les plus importants sont d'ordre climatiques et topographiques. Ces résultats confirment les premières observations de l'ACP.
Les variables d'occupation du sol ont une influence secondaire et celles qui agissent significativement sont la proportion des exploitations ayant une OTEX de type élevage en 1988, la proportion de surface fourragère principale en 1988 et les proportions de maïs fourrage dans la SAU pour les années 1988, 1979 et 1970. Parmis ces variables d'occupation du sol, l'années 1988 explique bien les teneurs en carbone organique pour la période 1995-1999.

**En conclusion** Ces résultats montrent le caractère multifactoriel de la répartition des teneurs en carbone organique à l'échelle national. Pour évaluer l'effet de l'évolution de l'occupation du sol sur les teneurs en C, il est nécessaire de travailler sur des zones géographiques contextes topographiques et climatiques homogènes.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("gbm_fr","Importance des variables explicatives"),fig.align="center"}
load(paste(repsortie,"mgbm_fr1302.RData",sep=""))
plotvarimp <- plot(varImp(mgbm), top = 10)
png(paste(repsortie,"varimp_fr.png",sep=""), width = 1000, height = 1000,res=150)  
plotvarimp
dev.off()

```

```{r gbmstratification,eval=FALSE,echo=FALSE}
# Stratification par zonage des grandes régions d'élevage
set.seed(157) #Pour assurer la reproductibilité
registerDoMC(4)

p <- list()
for(i in levels(as.factor(dcast.bdat$typo_clim))){
  print(i)
  d_typo <- dcast.bdat[dcast.bdat$typo_clim %in% i,vNames]
  #d_typo[vNames[1]] <- log(d_typo[vNames[1]])
  
  datax <- d_typo[, vNames[-1]]
  datay <- d_typo[, vNames[1]]


  #formula <- as.formula(paste(vNames[1],"~",paste(vNames[-1],collapse="+"),sep=""))
 
  trControl <- trainControl(method = "cv",p=0.8,number=10)
  tuneGrid <- expand.grid(interaction.depth = mgbm$bestTune$interaction.depth,n.trees = mgbm$bestTune$n.trees,shrinkage = 0.1,n.minobsinnode = 10)

  # Utilisation de caret, car plus rapide qu'une simple fonction gbm
  mgbm_strat <- train(x = datax , y = datay,method="gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)

#  mgbm_strat <- try(train(formula,data=d_typo,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T,na.action = na.omit),silent=TRUE)

  if(class(mgbm_strat)[1]=="try-error"){
    print("Pas assez d'échantillons pour la modélisation")
    next
  }

  varimport <- varImp(mgbm_strat)
  varimport <- as.data.frame(varimport[[1]])
  varimport$variable <- rownames(varimport)
  colnames(varimport) <- c("importance","variable")
  #varimport <- varimport[order(varimport$importance,decreasing = TRUE),]
  varimport$variable <- reorder(varimport$variable, varimport$importance)
  varimport <- varimport[1:10,]
  varimport$type <- gsub2(as.character(Rcovar),type,as.character(varimport$variable))#Ajout du type de facteurs

  p[[i]] <- ggplot(varimport, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(stat = "identity") + coord_flip() + labs(title=i)
}
save(p,file=paste(repsortie,"p_mgbm_stratefr.RData",sep=""))
```
Ci-dessous, commenter les résultats de la stratification avec les types de climat

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=6,fig.cap = fig$cap("gbm_strat_fr","Importance des variables explicatives"),fig.align="center"}
load(paste(repsortie,"p_mgbm_stratefr.RData",sep=""))
do.call(grid_arrange_shared_legend,c(p,list(nrow=3,ncol=2,position="bottom")))
```

```{r gbmstratificationelevage,eval=FALSE,echo=FALSE}
# Stratification par zonage des grandes régions d'élevage
set.seed(157) #Pour assurer la reproductibilité
registerDoMC(4)

#dcast.bdat$classe_altimean
p <- list()
for(i in levels(as.factor(dcast.bdat$zonage_simple))){
  print(i)
  d_typo <- dcast.bdat[dcast.bdat$zonage_simple %in% i,vNames]
  datax <- d_typo[, vNames[-1]]
  datay <- d_typo[, vNames[1]]

 # d_typo[vNames[1]] <- log(d_typo[vNames[1]])
 # formula <- as.formula(paste(vNames[1],"~",paste(vNames[-1],collapse="+"),sep=""))
 # formula <- as.formula(paste(vNames[1],"~",paste(vNames[-1],collapse="+"),sep=""))
 
  trControl <- trainControl(method = "cv",p=0.8,number=10)
  tuneGrid <- expand.grid(interaction.depth = mgbm$bestTune$interaction.depth,n.trees = mgbm$bestTune$n.trees,shrinkage = 0.1,n.minobsinnode = 10)

  mgbm_elevage <- train(x = datax , y = datay,method="gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T)

  #mgbm_elevage <- try(train(formula,data=d_typo,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T,na.action = na.omit),silent=TRUE)

  if(class(mgbm_elevage)[1]=="try-error"){
    print("Pas assez d'échantillons pour la modélisation")
    next
  }

  varimport <- varImp(mgbm_elevage)
  varimport <- as.data.frame(varimport[[1]])
  varimport$variable <- rownames(varimport)
  colnames(varimport) <- c("importance","variable")
  #varimport <- varimport[order(varimport$importance,decreasing = TRUE),]
  varimport$variable <- reorder(varimport$variable, varimport$importance)
  varimport <- varimport[1:10,]
  varimport$type <- gsub2(as.character(Rcovar),type,as.character(varimport$variable))#Ajout du type de facteurs

  p[[i]] <- ggplot(varimport, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(stat = "identity") + coord_flip() + labs(title=i)
}

save(p,file=paste(repsortie,"p_mgbm_elevage.RData",sep=""))
```
Ci-dessous, commenter les résultats de la stratification avec les principales régions d'élevage

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=12,fig.cap = fig$cap("gbm_strat_elevage","Importance des variables explicatives"),fig.align="center"}
load(paste(repsortie,"p_mgbm_elevage.RData",sep=""))
do.call(grid_arrange_shared_legend,c(p,list(nrow=3,ncol=3,position="bottom")))
```

```{r gbmstratregion,eval=FALSE,echo=FALSE}
# Stratification par région administrative
set.seed(157) #Pour assurer la reproductibilité
registerDoMC(4)

p <- list()
for(i in levels(as.factor(dcast.bdat$nom_region))){
  print(i)
  d_typo <- dcast.bdat[dcast.bdat$nom_region %in% i,vNames]
#  d_typo[vNames[1]] <- log(d_typo[vNames[1]])
  
  formula <- as.formula(paste(vNames[1],"~",paste(vNames[-1],collapse="+"),sep=""))
 
  trControl <- trainControl(method = "cv",p=0.8,number=5)
  tuneGrid <-  expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:50)*10,shrinkage = 0.1,n.minobsinnode = 20)

  mgbm_region <- try(train(formula,data=d_typo,"gbm",tuneGrid = tuneGrid,trControl = trControl,verbose = F,keep.data = T,na.action = na.omit),silent=TRUE)

  if(class(mgbm_region)[1]=="try-error"){
    print("Pas assez d'échantillons pour la modélisation")
    next
  }

  varimport <- varImp(mgbm_region)
  varimport <- as.data.frame(varimport[[1]])
  varimport$variable <- rownames(varimport)
  colnames(varimport) <- c("importance","variable")
  #varimport <- varimport[order(varimport$importance,decreasing = TRUE),]
  varimport$variable <- reorder(varimport$variable, varimport$importance)
  varimport <- varimport[1:10,]
  varimport$type <- gsub2(as.character(Rcovar),type,as.character(varimport$variable))#Ajout du type de facteurs

  p[[i]] <- ggplot(varimport, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(stat = "identity") + coord_flip() + labs(title=i)
}

save(p,file=paste(repsortie,"p_mgbm_strateregion.RData",sep=""))
```
Ci-dessous, commenter les résultats de la stratification avec les types de climat

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=15,fig.cap = fig$cap("gbm_region_fr","Importance des variables explicatives"),fig.align="center"}
load(paste(repsortie,"p_mgbm_strateregion.RData",sep=""))
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))
```

#### Graphiques de correlation

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("correlation","Graphiques de correlation"),fig.align="center"}

Rcovar <- c("pluie_ecart_janv","hpluie_an","altimean","jfroids_an","p_sfp1988","polyelevage1988","ampli_t_juil_janv","p_prairie1988","p_mf1979","p_sfp1970","elevagehorsol1988","p_mf1970","p_mf1988","p_c1979","grdcultures1988")
vNames <- c("corgox_medequi9599",Rcovar) #9599 car meilleure représentation spatiale, il faudra mieux justifier l'étude de cette variable


xlabel <- "Pluie annuelle (mm)"
ylabel <- "Carbone organique (g/kg)"
period <- c("9094","9599","0004","0509","1014") #
colors <- brewer.pal(5,"Set1")

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_p_sfp1988) & complete.cases(dcast.bdat$hpluie_an) & complete.cases(dcast.bdat[,c_period]),]
#  dataplot[,c_period] <- log(dataplot[,c_period])
  
  p[[i]] <- ggplot(dataplot, aes_string("hpluie_an",c_period)) +
            geom_point(aes(colour = factor(classe_p_sfp1988)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="% de sfp (1988)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=800, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,"hpluie_an"], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
  
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("altitude","Graphiques de correlation"),fig.align="center"}

xlabel <- "Altitude moyenne (m)"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_p_sfp1988) & complete.cases(dcast.bdat$altimean) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string("altimean",c_period)) +
            geom_point(aes(colour = factor(classe_p_sfp1988)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="% de sfp (1988)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=650, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,"altimean"], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")        
}
   
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_polyelevage","Graphe de correlation"),fig.align="center"}

xlabel <- "OTEX polyelevage1988"
covariable <- "polyelevage1988"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=50, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}

do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_elevagehorssol","Graphique de correlation"),fig.align="center"}

xlabel <- "OTEX elevage hors sol en 1988"
covariable <- "elevagehorsol1988"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=20, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_prairie1988","Graphique de correlation"),fig.align="center"}

xlabel <- "Pourcentage de prairie en 1988"
covariable <- "p_prairie1988"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=20, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}

do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_ugbta","Graphique de correlation"),fig.align="center"}

xlabel <- "Densité UGBTA/SAU en 1988"
covariable <- "ugbta1988"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=5, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_cereal","Graphique de correlation"),fig.align="center"}

xlabel <- "Pourcentage en céréales en 1988"
covariable <- "p_c1988"

p <- list()
for(i in period){
  c_period <- paste("corgox_medequi",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=20, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))

```

### Conclusion

Ici, conclure en disant que l'analyse des teneurs france entière et des dynamiques n'est pas facile en raison de :

- les dynamiques régionales spécifiques peuvent être noyées (pourquoi?) dans la masse...
- la part des facteurs contrôlant la distribution (climat, l'occup du sol...)


## Par type de climat

Compte tenu de l'importance des variables climatiques dans le contrôle de la distribution spatiale des teneurs en carbone organique, une stratification des analyses précédemment réalisées est proposée. Celle-ci est basée sur une typologie des types de climat (rajouter ref). En raison de l'hétérogénéité spatiale des analyses de la BDAT (rajouter carte avec distribution du nombre d'effectif par canton), l'analyse est seulement portée sur les zones 1, 2, 3, 4 et 5.

### Cartographie des types de climat
La carte ci-dessous présente la typologie.

```{r map_climat_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"typo_clim.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Courbes de fréquence cumulées

```{r cdf_clim,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=10, fig.width=12,fig.cap = fig$cap("cdf_clim",""),fig.align="center"}

xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
colour <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")
type_clim <- 1:5

melted.bdat_clim <- melted.bdat[(melted.bdat$typo_clim %in% type_clim),]

cdf_clim <- ggplot(melted.bdat_clim, aes(x=value))+
       facet_wrap(~typo_clim)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colour, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_clim
ggsave(cdf_clim,file = paste(repsortie,"cdf_clim.png",sep=""), width = 12, height = 10)  

```

La figure `r fig$ref("cdf_clim",link=TRUE)` présente les courbes de fréquence cumulées pour les différents types de climats.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("boxplot_clim",""),fig.align="center"}

p <- ggplot(melted.bdat_clim) +
            geom_boxplot(aes(x=annees,y=value,col=typo_clim),notch=TRUE)+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=zonage_simple,fill=zonage_simple),method=loess)+
            #scale_color_manual(values=colors,name="Années")
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
p  
ggsave(p,file = paste(repsortie,"boxplot_clim.png",sep=""), width = 7, height = 6)  
```

La figure `r fig$ref("boxplot_clim",link=TRUE)` représente la distribution  des teneurs en carbone organique sous forme de boxplot pour les différentes périodes et les différentes zones climatiques. COMMENTER

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("boxplot_clim",""),fig.align="center"}
ylim1 <- c(min(melted.bdat_clim$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))
colors <- brewer.pal(4,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

boxplot_clim <- ggplot(melted.bdat_clim) +
            geom_boxplot(aes(x=annees,y=value,col=annees),outlier.shape = NA,outlier.size=NA)+
            facet_wrap(~typo_clim,scales="free")+
            scale_color_manual(values=colors,name="Périodes")+
            geom_smooth(aes(x=as.integer(annees),y=value),method=loess,color="black")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)
boxplot_clim
ggsave(boxplot_clim,file = paste(repsortie,"boxplot_clim2.jpg",sep=""), width = 7, height = 6)  

```


```{r,highlight=TRUE,eval=TRUE,echo=TRUE}
p <- list()
for(i in levels(as.factor(melted.bdat$typo_clim))){
  print(i)
  melted.test <- melted.bdat[melted.bdat$typo_clim %in% i,]
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
}
```

## Par régions d'élevage

Cette section développe une analyse des teneurs en carbone organique pour les principales régions d'élevage. En raison de l'hétérogénéité spatiale des analyses de la BDAT (rajouter carte avec distribution du nombre d'effectif par canton), l'analyse est uniquement réalisée sur les régions d'élevage suivante : 
- A :
- B1 :
- B2 :
- C1 :
- C2 :
- D :

###Cartographie des régions d'élevage

```{r,echo=FALSE,eval=FALSE}
tablecarto <- "dm_vecteurs.canton" #Nom de la table utilisée pour la cartographie (table postgis)
variablecarto <- "zonage_cplt"
style_classe <- "fixed"#Nombre de classes de valeurs pour la cartographie
couleur <- "Paired" #RdYlBu
l_variable <- "Principales régions d'élevage" #label de la variable
nomfichier <- "reg_elevage_cplt" #Nom du fichier
carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=1,ncollayout=1,position="bottom",ggsaveheight=7,ggsavewidth=10)

variablecarto <- "zonage_simple"
style_classe <- "fixed"#Nombre de classes de valeurs pour la cartographie
couleur <- "Paired" #RdYlBu
l_variable <- "Principales régions d'élevage" #label de la variable
nomfichier <- "reg_elevage_simple" #Nom du fichier
carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=1,ncollayout=1,position="bottom",ggsaveheight=7,ggsavewidth=10)
```

```{r map_regelevage_fr, echo = F, results = 'asis'}
# Pour insérer l'image
nomfichier <- c("reg_elevage_cplt.png","reg_elevage_simple.png")
fichiers <- paste(repsortie,nomfichier,sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Analyses par régions d'élevage

La figure `r fig$ref("cdf_regelevage",link=TRUE)` présente les courbes de fréquences cumulées pour les différentes régions d'élevage.

```{r cdf_regelevage,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=10, fig.width=12,fig.cap = fig$cap("cdf_regelevage",""),fig.align="center"}
#reg_elevage <- c("A","B1","B2","C1","C2","D","G1","G2")
#melted.bdat_regelevage <- melted.bdat[complete.cases(melted.bdat$zonage_cplt) & melted.bdat$zonage_cplt %in% reg_elevage,]
melted.bdat_regelevage <- melted.bdat[complete.cases(melted.bdat$zonage_simple) & (melted.bdat$zonage_simple != "H"),]

cdf_regelevage <- ggplot(melted.bdat_regelevage, aes(x=value))+
       facet_wrap(~zonage_cplt)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colour, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_regelevage

ggsave(cdf_regelevage,file = paste(repsortie,"cdf_regelevage.png",sep=""), width = 12, height = 10) 

```

Ci-dessous, on regarde la répartition des teneurs en C pour les différentes périodes et par les principales régions d'élevage. (voir figure `r fig$ref("boxplot_regelevage",link=TRUE)`).

```{r boxplot_reg_elevagezoom,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=12,fig.cap = fig$cap("boxplot_regelevage",""),fig.align="center"}
p <- ggplot(melted.bdat_regelevage) +
            geom_boxplot(aes(x=annees,y=value,col=zonage_cplt),notch=TRUE)+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=zonage_simple,fill=zonage_simple),method=loess)+
            #scale_color_manual(values=colors,name="Années")
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
p  
ggsave(p,file = paste(repsortie,"boxplotbdat_zonage_cplt.png",sep=""), width = 12, height = 6)  
```


```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=12,fig.cap = fig$cap("boxplot_regelevage2",""),fig.align="center"}
#ylim1 <- boxplot.stats(melted.bdat$value)$stats[c(1,5)]

# Relancer
ylim1 <- c(min(melted.bdat_regelevage$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))
colors <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

boxplot_reg_elevage <- ggplot(melted.bdat_regelevage) +
            geom_boxplot(aes(x=annees,y=value,col=annees),outlier.shape = NA,outlier.size=NA)+
            facet_wrap(~zonage_cplt,scales="free")+
            scale_color_manual(values=colors,name="Périodes")+
            geom_smooth(aes(x=as.integer(annees),y=value),method=loess,color="black")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)
boxplot_reg_elevage

ggsave(boxplot_reg_elevage,file = paste(repsortie,"boxplot_reg_elevage.png",sep=""), width = 12, height = 8)  

```

```{r boxplotbdat_classeoccup,highlight=TRUE,eval=FALSE,echo=FALSE}

for(i in id_class){
  melted.bdat_ra <- melted.bdat[complete.cases(melted.bdat[,i]),]
  names(melted.bdat_ra)[names(melted.bdat_ra)==i] <- "classe"
  
  p <- ggplot(melted.bdat_ra) +
            geom_boxplot(aes(x=annees,y=value,col=classe),notch=TRUE)+
            #scale_color_manual(name="Années")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
  p  
  ggsave(p,file = paste("boxplotbdat_",i,".png",sep=""), width = 15, height = 10)  
}
```

```{r,highlight=TRUE,eval=FALSE,message=FALSE,echo=FALSE}
# Ici, voir pour rajouter année+zonage_simple ou année+climato ou année+région
bdatsummary_regelevage <- apply(melted.bdat["value"],2, function(x) tapply(x, list(melted.bdat[,"zonage_simple"],melted.bdat[,"annees"]),summary))
bdatsummary_regelevage <- data.frame(bdatsummary_regelevage[[1]])
bdatsummary_regelevage <- lapply(bdatsummary_regelevage, do.call, what = rbind)
names(bdatsummary_regelevage) <- period

# Revoir pour construire une table plus lisible
#pander(bdatsummary_regelevage,caption = "Statistiques descriptives par période des teneurs en CO pour les principales régions d'élevage")


# Ici, voir pour rajouter année+zonage_simple ou année+climato ou année+région
bdatsummary_regadmin<- apply(melted.bdat["value"],2, function(x) tapply(x, list(melted.bdat[,"nom_region"],melted.bdat[,"annees"]),summary))
bdatsummary_regadmin <- data.frame(bdatsummary_regadmin[[1]])
bdatsummary_regadmin <- lapply(bdatsummary_regadmin, do.call, what = rbind)
names(bdatsummary_regadmin) <- period

# Revoir pour construire une table plus lisible
#pander(bdatsummary_regadmin,caption = "Statistiques descriptives par période des teneurs en CO pour les différentes régions administratives")

```

```{r,highlight=TRUE,eval=TRUE,echo=TRUE}
p <- list()
for(i in levels(as.factor(melted.bdat$zonage_cplt))){
  print(i)
  melted.test <- melted.bdat[melted.bdat$zonage_cplt %in% i,]
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])

bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
bdatsummary <- lapply(bdatsummary, do.call, what = rbind)

ggplot(melted.test) +
            geom_boxplot(aes(x=annees,y=value),notch=TRUE)

}
```

