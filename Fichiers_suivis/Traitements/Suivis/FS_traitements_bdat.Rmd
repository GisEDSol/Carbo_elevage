---
title: "Analyse des teneurs en carbone organique de la BDAT"
author: "Jean-Baptiste Paroissien"
date: "07/03/2017"
output:
  html_document:
    toc: yes
    toc_float: yes
    fig_caption: yes
    highlight: kate
    number_sections: yes
    theme: spacelab   
---

```{r setup, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
# Importation des paramètres de travail
source("/media/sf_GIS_ED/Dev/Scripts/master/Fonctions/R/importparametres.R")
repmaster <- "/media/sf_GIS_ED/Dev/Scripts/master/"
importparametres(repmaster=repmaster,repdata="/media/sf_GIS_ED/Dev/Data/",dsn="PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'")
repsortie <- paste(repmaster,"Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers

set.seed(157) #Pour la reproductibilité
cl <- makeCluster(4);registerDoParallel(cl) #Configuration pour le calcul en parallèle
```

```{r,eval=TRUE,echo=FALSE}
## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    
```

```{r date, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
date <- Sys.Date()
sessionInfo()
```

```{r, tidy=FALSE,eval=TRUE,echo=FALSE}
mo_url <- "https://github.com/GisEDSol/Carbo_elevage/tree/master/Documentation/Modes_operatoires/"
fs_url <- "https://github.com/GisEDSol/Carbo_elevage/tree/master/Fichiers_suivis/"
raw_mo_url <- "https://rawgit.com/GisEDSol/Carbo_elevage/master/Documentation/Modes_operatoires/"
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Lecture des tables de travail
#melted.bdat <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))
#period <- c("9094","9599","0004","0509","1014")
#melted.bdat$value <- as.numeric(melted.bdat$value)
#melted.bdat <- melted.bdat[complete.cases(melted.bdat$value),]
#melted.bdat$annees <- factor(melted.bdat$annees,levels=period)

# Jeu de données sur 4 périodes de temps
bdat9514 <- sqlQuery(loc,paste("select * from dm_vecteurs.canton_9514",sep=""))
melted.9514 <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat_9514",sep=""),as.is=c(FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,FALSE))
melted.9514$value <- as.numeric(melted.9514$value)
melted.9514 <- melted.9514[complete.cases(melted.9514$value),]
melted.9514$annees <- factor(melted.9514$annees,levels=c("9599","0004","0509","1014"))

# Sélection des teneurs mesurées avec la méthode OX
melted.9514 <- melted.9514[melted.9514$variable %in% "corgox",]

# Changement du nom des tables pour l'exploitation rapide dans le fichier de suivi
dcast.bdat <- bdat9514
melted.bdat <- melted.9514 
```

# Objectifs

L'objectif de ce travail est d'analyser la distribution statistiques et géographiques des teneurs en Carbone Organique (CO) de la BDAT pour les 5 périodes de temps suivantes : 1990-1994, 1995-1999, 2000-2004, 2005-2009 et 2010-2014. Dans un premier temps, le travail est porté à l'échelle de la France afin d'appréhender globalement les différences entre les périodes de temps. Le même travail est ensuite reconduit sur différentes strates géographiques pour affiner les résultats sur différentes échelles géographiques. Enfin, la troisième étape propose d'analyser la répartition spatiale des teneurs avec des facteurs explicatifs potentiels. 

Les résultats présentés font suite à différents scripts de préparation de données dont la chaîne de traitements générale est consultable à cette [adresse](`r raw_mo_url`Figures/workflow.html).

# Analyse des teneurs en carbone organique par période (France)

Cette première étape a pour but d'analyser les teneurs en CO de la BDAT pour chacune des périodes de temps analysées. La cartographie des teneurs en CO est présentée dans un premier temps et les statistiques descriptives (courbes de fréquences cumulées et boxplot) sont présentées dans un second temps.

## Représentation cartographique

### Cartographie des effectifs de la BDAT

La cartographie du nombre d'analyse de la BDAT par canton pour les teneurs en CO est présentée dans la figure ci-dessous. Cette figure met en évidence une importante variabilité spatio-temporelle du nombre d'analyse. De façon générale (toutes périodes confondues), le nombre d'effectif est plus important sur la partie nord et ouest du pays. Le Massif Central et le Sud-Est sont faiblement concentrés en effectifs.

Les variabilité sont également marquées dans le temps. La période 9094 est entachée par l'abscence d'analyses dans de nombreuses régions dont la Normandie. Les autres périodes présentes une distribution des analyses plus stables.

> **Compte-tenu du manque de données dans la première période 9094, celle-ci ne sera pas prise en compte dans les analyses des teneurs en CO à l'échelle de la France.** 

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
# Paramètres #################
tablecarto <- "dm_vecteurs.canton" #Nom de la table utilisée pour la cartographie (table postgis)
variable <- "eff_corgox"
period <- c("9094","9599","0004","0509","1014") #
variablecarto <- paste(variable,period,sep="")#variables à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- "YlOrRd" #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Nombre d'échantillon par canton" #label de la variable
nomfichier <- "effectif_bdat_corgox" #Nom du fichier

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=3,position="bottom",ggsaveheight=7,ggsavewidth=9.2)
```

```{r carto_effectif_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"effectif_bdat_corgox.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Cartographie des teneurs en carbone organique (CO)

La cartographie des teneurs en CO de la BDAT est présentée dans les figures ci-dessous. Celle-ci est réalisée uniquement sur les 4 dernières périodes (9599, 0004, 0509, 1014) et appliquée sur un masque pour analyser les teneurs sur un nombre de canton commun entre les périodes.

La cartographie montre une distribution spatiale organisée et globalement similaire pour les différentes périodes analysées. De façon générale, cette organisation suit la lithologie du pays avec de fortes teneurs en carbone organique présentes dans les zones de socles et de piemonds et des valeurs plus faibles dans les principaux bassins sédimentaires (parisien et aquitain).

```{r ,highlight=TRUE,eval=FALSE,echo=FALSE}
tablecarto <- "dm_vecteurs.canton_9514" #Nom de la table utilisée pour la cartographie (table postgis)
period <- c("9599","0004","0509","1014") #
variable <- "corgox"
variablecarto <- paste(variable,period,sep="")#variables à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- "YlOrRd" #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Teneur en carbone organique (g/kg)" #label de la variable
nomfichier <- "corgox_period_fr" #Nom du fichier

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=2,position="bottom",ggsaveheight=7,ggsavewidth=7)
```
```{r carto_c_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"corgox_period_fr.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

## Statistiques descriptives

La figure `r fig$ref("cdf_fr",link=TRUE)` présente les courbes de fréquences cumulées des teneurs en carbone organique distribuées pour les 4 périodes identifiées. Les courbes de fréquences des 4 périodes présentent la même forme en "S" et s'individualisent juste avant le plateau, présentant une différence affectant les sols riches en teneurs organiques (entre 17 et 45 g/kg). Sur cette zone (figure à droite), la figure montre un décalage des courbes des périodes 2000-2004, 2005-2009 et 2010-2014 vers des valeurs plus faibles. Parmi ces 3 périodes, la période 2005-2009 est celle qui se décale le plus vers des teneurs plus faible tandis que la période 2010-2014 se rapproche des valeurs de 1995-1999, présentant ainsi une inversion de la tendance observée.

**Ces observations mettent en évidence une diminution des teneurs en carbone entre les périodes 1990-1999 et 2000-2009 et une légère augmentation pour la période 2010-2014.**

```{r cdf_fr,highlight=TRUE,echo=FALSE,eval=TRUE,warning=FALSE,error=FALSE,fig.height=5, fig.width=7,fig.cap = fig$cap("cdf_fr","Courbe de fréquences cumulées"),fig.align="center"}

period <- c("9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
nperiod <- length(period)
colors <- brewer.pal(nperiod,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

p <- list()
# Courbe de fréquence cumulée
p[[1]] <- ggplot(melted.bdat, aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))

#ggsave(p[[1]],file = paste(repsortie,"cdf_fr1.png",sep=""), width = 9, height = 7)  
p[[2]] <- ggplot(melted.bdat[(melted.bdat$value > 17) & (melted.bdat$value < 45) ,], aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))

#ggsave(p[[2]],file = paste(repsortie,"cdf_fr2.png",sep=""), width = 9, height = 7)  

tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))
#ggsave(tt,file = paste(repsortie,"cdf_fr.pdf",sep=""), width = 10, height = 7)  
```

```{r summarybdatfrance,echo=FALSE,eval=TRUE}
# Résumé des statistiques 
bdatsummary <- apply(melted.bdat["value"],2, function(x) tapply(x, melted.bdat[,"annees"],summary))
bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
```
La distribution des teneurs en carbone organique par période est présentée figure `r fig$ref("boxplot_fr",link=TRUE)` et statistiques associées le tableau ci-dessous. La tendance de diminution des teneurs observée dans la figure `r fig$ref("cdf_fr",link=TRUE)` est également constatée dans ces deux éléments. La période 2000-2004 montre la valeur médiane la plus faible avec une valeur de `r bdatsummary$value["0004","Median"]` g/kg. Les valeurs les plus importantes sont observées pour les périodes 1995-1999 et 1014 avec des médianes de teneurs en carbone organique équivalente, à `r bdatsummary$value["9599","Median"]` g/kg. Ces évolutions sont très légèrement marquées sur la figure `r fig$ref("boxplot_fr",link=TRUE)` où l'évolution moyenne des teneurs en carbone organique baisse légèrement après la période 1995-1999.

```{r summarybdatfrancetable,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',warning=FALSE,message=FALSE}
pander(bdatsummary[[1]],caption = "Statistiques descriptives des teneurs en carbone organique pour les différentes périodes")
```

```{r boxplot_fr,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=5, fig.width=6,fig.cap = fig$cap("boxplot_fr","Boxplot des teneurs en carbone organiques par périodes"),fig.align="center",warning=FALSE,message=FALSE}

p <- ggplot(melted.bdat, aes(x=annees,y=value)) + 
  #geom_violin(trim=FALSE)+
  #geom_boxplot(width=0.1, fill="white")+
  geom_boxplot()+
  #scale_color_manual(values=colors,name="Années")+
  geom_smooth(method = "loess", se=FALSE, color="black", aes(group=1))+
  scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone organique (g/kg)")+
  theme(plot.title = element_text(size = 14, face = "bold"), 
        text = element_text(size = 12),
        axis.title = element_text(face="bold"),
        axis.text.x=element_text(size = 11))
p
#ggsave(p,file = paste(repsortie,"boxplotbdat.png",sep=""), width = 5, height = 6)  
```
Les résultats du test de Wilcoxon présentés ci-dessous montrent que **les différences à l'échelle de la France entre les périodes sont significatives pour les baisses de [1995-1999 et 2000-2004], [1995-1999 et 2005-2009] et l'augmentation des teneurs entre les périodes [2000-2004 et 2010-2014]**. Ces résulats confirment les tendances observées sur les courbes de fréquences cumulées (voir figure `r fig$ref("cdf_fr",link=TRUE)`).

```{r,highlight=TRUE,eval=TRUE,echo=TRUE}
pairwise.wilcox.test(melted.bdat[,"value"], melted.bdat[,"annees"])
```

## Conclusion

La médiane cantonale des teneurs en CO des analyses de la BDAT a évolué significativement entre les périodes de temps étudiées (de 1995 à 2014). De 1995 à 2005-2009, la médiane des médianes des teneurs a diminué, passant de 14 g/kg à 13.70 g/kg. Cette tendance s'est inversée significativement entre les périodes 2000-2000 et 2010-2014 pour finalement revenir aux teneurs initiales de 1995-1999, à 14 g/kg.

**Rajouter une discussion sur les résultats de Bellamy et al., 2005**

Ce travail d'analyse sur l'ensemble du territoire est reconduit sur plusieurs strates géographiques afin d'étudier les évolutions sur des compartiments environnementaux homogènes, du point de vue du climat et de l'occupation du sol.

# Analyse des teneurs en carbone organique par période (Strates)

L'analyse des teneurs en CO est appliquée à l'échelle de plusieurs de strates. Ces strates représentent des entités géographiques homogènes d'un point de vue climatique, de type d'élevage ou encore géologique.
L'analyse par strate peut permettre d'observer des tendances régionales à l'intérieur desquelles les mécanismes d'évolution des teneurs en CO sont supposés homogènes.

## Analyse par type de climat

Compte tenu de l'importance des variables climatiques dans le contrôle de la distribution spatiale des teneurs en carbone organique, une stratification des analyses précédemment réalisées est proposée. Celle-ci est basée sur une typologie des types de climat [Joly et al., 2010](http://cybergeo.revues.org/23155). La typologie est consultable sur cette [page](https://github.com/GisEDSol/Carbo_elevage/blob/master/Documentation/Metadonnees/Nomenclature_typeclimat.csv).

*La construction des données climatiques est consultable sur ce fichier [FS_bdd_elab_climat.Rmd](https://github.com/GisEDSol/Carbo_elevage/blob/master/Fichiers_suivis/BDD/Suivis/FS_bdd_elab_climat.Rmd)*

Le tableau ci-dessus présente le nombre de canton pourvu en analyse de la BDAT par type de climat. Les types de climats **6, 7 et 8** englobent moins de 100 cantons. Ils seront écartés de l'analyse.
Parmi les strates restantes, la variabilité dans le nombre d'analyse est importante, passant de 163 pour le type 1 à 722 pour le type 3.

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
#melted.bdat$typo_climsple <- melted.bdat$typo_clim
#melted.bdat$typo_climsple[melted.bdat$typo_climsple %in% c("4","5")] <- "45"
p <- list()
for(i in levels(as.factor(melted.bdat$typo_clim))){
  melted.test <- melted.bdat[melted.bdat$typo_clim %in% i,]
  p[[i]] <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
}
clim_nbranalyses <- as.data.frame(melt(p))
colnames(clim_nbranalyses) <- c("Nbr","Type_climat")
pander(clim_nbranalyses[,c("Type_climat","Nbr")],caption="Nombre de canton possédant des analyses par type de climat")
```

### Cartographie des types de climat

La carte ci-dessous présente la typologie proposée. Pour une description des types de climat, voir [Joly et al., 2010](http://cybergeo.revues.org/23155).

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
tablecarto <- "dm_vecteurs.canton" 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" 
variablecarto <- "typo_clim" #variable à spatialiser
l_legend <- "Type de climat"#label de la variable
nclasse <- 8 #Nombre de classes de valeurs pour la cartographie
style_classe <- "fixed" #"pretty"#"jenks","fixed"
couleur <- "Paired"#nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
nomfichier <- "typo_clim"

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_legend,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=1,ncollayout=1,position="bottom",ggsaveheight=7,ggsavewidth=10)  
```

```{r, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"typo_clim.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Courbes de fréquences cumulées

```{r cdf_clim,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=10, fig.width=12,fig.cap = fig$cap("cdf_clim",""),fig.align="center"}
#pROBLÈME
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
colour <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")
#typo_climsple <- c("1","2","3","45")
typo_clim <- 1:5

melted.bdat_clim <- melted.bdat[(melted.bdat$typo_clim %in% typo_clim),]

cdf_clim <- ggplot(melted.bdat_clim, aes(x=value))+
       facet_wrap(~typo_clim)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colour, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_clim
#ggsave(cdf_clim,file = paste(repsortie,"cdf_clim.png",sep=""), width = 12, height = 10)  
```
La figure `r fig$ref("cdf_clim",link=TRUE)` présente les courbes de fréquence cumulées pour les différents types de climats. Les courbes de fréquences cumulées pour les 3 types de climats sélectionnés présentent une forme similaire. Les courbes des différentes périodes tendent vers des valeurs de teneurs en CO plus faible sur une large gamme de teneur pour les types de climat 3 et 4. Dans ces 2 cas, les périodes 0004 et 0509 présentent des valeurs plus faibles que les teneurs 9599 et 1014. Dans le type de climat 4, l'évolution des teneurs s'accentue sur la gamme 17-30 g/gk. Sur cette gamme, la période 1014 est particulièrement contributrice de la baisse des teneurs. A l'inverse, la période 0509 montrent des teneurs en CO plus forte pour cette gamme de valeur.

La courbe de fréquence cumulée pour le type de climat 5 présente une dynamique similaire avec des changements important pour les teneurs en CO de 20-30 g/kg. Dans cette situation, la période 1014 présente également une courbe avec des teneurs en CO plus faible que la période 9599 et des teneurs en CO plus forte pour 0509 et 0004.

**Cette figure montre des tendances comparables entre les types de climats. L'évolution des teneurs en CO est différente en fonction des gammes des teneurs en CO : la période 1014 présente de forte diminution sur les teneurs 17-30 g/kg et une augmentation sur les teneurs inférieures. Les périodes 0004 et 0509 affichent une tendance inverse**

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("boxplot_clim",""),fig.align="center",warning=FALSE,message=FALSE}

ylim1 <- c(min(melted.bdat_clim$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))
colors <- brewer.pal(4,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

boxplot_clim <- ggplot(melted.bdat_clim) +
            geom_boxplot(aes(x=annees,y=value,col=annees),outlier.shape = NA,outlier.size=NA)+
            facet_wrap(~typo_clim,scales="free")+
            scale_color_manual(values=colors,name="Périodes")+
            geom_smooth(aes(x=as.integer(annees),y=value),method=loess,color="black")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)
boxplot_clim
#ggsave(boxplot_clim,file = paste(repsortie,"boxplot_clim2.jpg",sep=""), width = 7, height = 6)  
```

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE,results="asis"}
panderOptions('knitr.auto.asis', FALSE)
p <- list()
for(i in levels(as.factor(melted.bdat_clim$typo_clim))){
  melted.test <- melted.bdat_clim[melted.bdat_clim$typo_clim%in% i,]   
  bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
  nbrobservation <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
  bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
  pander(bdatsummary[[1]],caption = paste("Statistiques descriptives des teneurs en carbone organique pour le type de climat ",i,". Nombre de canton analysé : ",nbrobservation,sep=""))
}
```


La figure `r fig$ref("boxplot_clim",link=TRUE)` représente la distribution des teneurs en carbone organique sous forme de boxplot pour les différentes périodes et les différentes zones climatiques. Les tableaux ci-dessus présentent les statistiques descriptives des teneurs en CO pour les différentes périodes et les différents types de climat. De ces tableaux et des boxplots, les zones 3 et 4 présentent une dynamique similaire avec une baisse puis une augmentation des teneurs. Ces évolutions se rapprochent des tendances nationales précédemment observées. Entre ces deux zones, seul les résultats pour le type de climat 3 sont significatifs. **La baisse des teneurs entre 9599 et 0004 et l'augmentation des teneurs en CO entre 0004 et 1014 et 0509-1014 sont significatives.** 

La zone 5 présente une évolution en dent de scie, avec une augmentation, une diminution et une augmentation. Ces évolutions ne sont pas significatives d'après le test de Wilcoxon.

```{r,eval=TRUE,echo=FALSE}
p <- list()
for(i in levels(as.factor(melted.bdat_clim$typo_clim))){
  melted.test <- melted.bdat_clim[melted.bdat_clim$typo_clim %in% i,]
  
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
}
print(p)
```

## Région d'élevage

Les grandes régions d'élevage représentent un zonage des principaux systèmes d'élevage en France. Le zonage a été construit sur la base de critères pédo-climatiques et d'un regroupement des petites régions agricoles. Par construction, ce zonage propose donc un regroupement de zones où les conditions d'apport, de stockage et d'évolution de carbone dans le sol peuvent être homogène.

**Il représente donc un zonage intéressant à exploiter pour étudier les évolutions des teneurs en CO à l'échelle de la France sous le regard de compartiments fonctionnels homogènes.**

```{r ,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',warning=FALSE,message=FALSE}
p <- list()
for(i in levels(as.factor(melted.bdat$zonage_cplt))){
  melted.test <- melted.bdat[melted.bdat$zonage_cplt %in% i,]
  p[[i]] <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
}
regelevage_nbranalyses <- as.data.frame(melt(p))
colnames(regelevage_nbranalyses) <- c("Nbr","Region_elevage")

pander(regelevage_nbranalyses[,c("Region_elevage","Nbr")],caption="Nombre de canton possédant des analyses par type de région d'élevage")
```

Le tableau ci-dessus présente le nombre de canton ayant des analyses en teneurs en CO par type de région d'élevage. Les régions d'élevages où le nombre de canton est inférieur à 100 sont éliminées. Il reste donc les régions suivants :

- A : Zones de grandes cultures ou sans élevage
- B1 : Zone de polyculture-élevage du Bassin Aquitain & Rhône-Alpes & Alsace
- B2 : Zone de polyculture-élevage du Bassin Parisien
- C1 : Zone intensive du Grand Ouest (zone laitière avec alternatives à l’élevage)
- D : Zone herbagère du Nord-Ouest
- E1 : Zone herbagère du Nord-Est (de tradition laitière)
- E2 : Zone herbagère du Nord Massif-Central (de tradition allaitante)


Parmi les strates restantes, la variabilité dans le nombre d'analyse est importante, passant de 163 pour le type 1 à 722 pour le type 3. 

### Cartographie

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
tablecarto <- "dm_vecteurs.canton" 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" 
variablecarto <- "zonage_cplt" #variable à spatialiser
l_legend <- "Principales régions d'élevage"#label de la variable
nclasse <- 8 #Nombre de classes de valeurs pour la cartographie
style_classe <- "fixed" #"pretty"#"jenks","fixed"
couleur <- "Paired"#nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
nomfichier <- "reg_elevage_cplt"

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_legend,repsortie,nomfichier,dept=FALSE,reg=FALSE,nrowlayout=1,ncollayout=1,position="bottom",ggsaveheight=7,ggsavewidth=10)  
```

```{r, echo = F, results = 'asis',warning=FALSE,error=FALSE,message=FALSE}
# Pour insérer l'image
fichiers <- paste(repsortie,"reg_elevage_cplt.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

La figure `r fig$ref("cdf_regelevage",link=TRUE)` présente les courbes de fréquences cumulées pour les différentes régions d'élevage. Sur cette figure, on remarque l'effet les différences de la densité d'analyse par région. Les régions C2, G1 et G2 présentent des courbes en marche d'escalier, illustrant un nombre insuffisant de données.
Mise à part ces différences, la forme des courbes est globalement similaire pour les différentes strates des régions d'élevage. En revanche, les tendances d'évolution des teneurs en CO sont différentes. Par exemple, dans la région C2, la fréquences des teneurs fortes en CO augmente pour les périodes 0004-0509 tandis que ces mêmes périodes affichent des diminutions importantes sur les zones D et E1 notamment.

A ce niveau, il est difficile de rentrer dans le détail. D'autres figures sont produites ci-dessous pour améliorer l'analyse de l'évolution des teneurs au niveau des différentes régions d'élevage.

```{r cdf_regelevage,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=10, fig.width=12,fig.cap = fig$cap("cdf_regelevage",""),fig.align="center"}

period <- c("9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
colour <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")
reg_elevage <- c("A","B1","B2","C1","D","E1","E2")

melted.bdat_regelevage <- melted.bdat[complete.cases(melted.bdat$zonage_cplt) & (melted.bdat$zonage_cplt %in% reg_elevage),]

cdf_regelevage <- ggplot(melted.bdat_regelevage, aes(x=value))+
       facet_wrap(~zonage_cplt)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colour, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_regelevage
#ggsave(cdf_regelevage,file = paste(repsortie,"cdf_regelevage.png",sep=""), width = 12, height = 10) 
```
Avant tout, les tables ci-dessous présentent les résultats des tests de Wilcoxon. Mis à part les zones d'élevage A et dans une moindre mesure B1, l'ensemble des régions d'élevage ne présente pas de différences significatives. **Attention, il s'agit d'analyse à l'échelle de la région d'élevage et non du canton**.

Ces résultats atténuent les observations visibles sur les figures ci-dessous (voir figure `r fig$ref("boxplot_regelevage2",link=TRUE)`). Celles-ci présentent des évolutions frappantes et différentes selon les régions, mais elles ne sont pas significatives.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
p <- list()
for(i in levels(as.factor(melted.bdat_regelevage$zonage_cplt))){
  melted.test <- melted.bdat_regelevage[melted.bdat_regelevage$zonage_cplt %in% i,]
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])

bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
#ggplot(melted.test) + geom_boxplot(aes(x=annees,y=value),notch=TRUE)
}
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=12,fig.cap = fig$cap("boxplot_regelevage2",""),fig.align="center",warning=FALSE,message=FALSE}
ylim1 <- c(min(melted.bdat_regelevage$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))
colors <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

boxplot_reg_elevage <- ggplot(melted.bdat_regelevage) +
            geom_boxplot(aes(x=annees,y=value,col=annees),outlier.shape = NA,outlier.size=NA)+
            facet_wrap(~zonage_cplt,scales="free")+
            scale_color_manual(values=colors,name="Périodes")+
            geom_smooth(aes(x=as.integer(annees),y=value),method=loess,color="black")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)
boxplot_reg_elevage

ggsave(boxplot_reg_elevage,file = paste(repsortie,"boxplot_reg_elevage.png",sep=""), width = 12, height = 8)  
```

Ci-dessous, la figure présente la répartition des teneurs en C pour les différentes périodes et pour les principales régions d'élevage .

```{r boxplot_reg_elevagezoom,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=12,fig.cap = fig$cap("boxplot_regelevage",""),fig.align="center"}

p <- ggplot(melted.bdat_regelevage) +
            geom_boxplot(aes(x=annees,y=value,col=zonage_cplt),notch=TRUE)+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=zonage_simple,fill=zonage_simple),method=loess)+
            #scale_color_manual(values=colors,name="Années")
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))
p  
#ggsave(p,file = paste(repsortie,"boxplotbdat_zonage_cplt.png",sep=""), width = 12, height = 6)  
```

```{r,highlight=TRUE,eval=FALSE,message=FALSE,echo=FALSE}
# Ici, voir pour rajouter année+zonage_simple ou année+climato ou année+région
bdatsummary_regelevage <- apply(melted.bdat["value"],2, function(x) tapply(x, list(melted.bdat[,"zonage_simple"],melted.bdat[,"annees"]),summary))
bdatsummary_regelevage <- data.frame(bdatsummary_regelevage[[1]])
bdatsummary_regelevage <- lapply(bdatsummary_regelevage, do.call, what = rbind)
names(bdatsummary_regelevage) <- period
```

## Conclusion 

Ici, établir une première conclusion sur les statistiques descriptives des analyses de la BDAT.


# Analyse des facteurs contrôlant la distribution spatiale

Dans cette partie, les facteurs contrôlant la distribution spatiale des teneurs en carbone organique des différentes périodes sont analysés. Le travail est dans un premier temps porté par une analyse en composante principale pour identifier les relations entre les facteurs potentiellement explicatifs et identifier les principales variables d'intérêts. Dans un deuxième temps par une modélisation avec la méthode des arbres de régression boostés pour affiner l'analyser et classer les variables explicatives par ordre d'importance (contribution).

## Analyse en composante principale 

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Sélection des variables de travail
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
typeoccup <- replicate(length(Ranthrop), "occup")

type <- c(typeclimato,typetopo,typeoccup)
Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop,"classe_C")
vNames <- c("corgox9599",Rcovar)

# Lecture de la table sans les NA
lvNames <- length(vNames)
dcast.bdat_variables <- dcast.bdat[complete.cases(dcast.bdat[,vNames[-lvNames]]),vNames[-lvNames]]

# Création d'une classe de valeur pour le carbone
classe_valeur <- classIntervals(dcast.bdat_variables[vNames[1]][[1]],n=4,style="quantile",digits=1,na.rm=TRUE)[[2]]
dcast.bdat_variables[,"classe_C"] <- cut(dcast.bdat_variables[vNames[1]][[1]],breaks = data.frame(classe_valeur)[,1],include.lowest=T) 

res.pca <- PCA(dcast.bdat_variables[,!names(dcast.bdat_variables) %in% "classe_C"], quanti.sup=1,graph = FALSE)

#
pca <- fviz_pca_var(res.pca, axes = c(1,2),col.var="contrib") +
scale_color_gradient2(low="white", mid="blue", 
                  high="red", midpoint=50) + theme_minimal()
```

La figure `r fig$ref("pca_fr",link=TRUE)` présente la distribution des variables sur les axes 1 et 2 de l'ACP. Environ `r round(res.pca$eig[1,2]+res.pca$eig[2,2])` pourcent de l'information est contenu dans ces deux premiers axes. Description de la distribution des variables dans l'espace des ACP : 

- L'axe 1 représente `r round(res.pca$eig[1,2])`% de l'information. Cet axe est fortement associé à l'occupation du sol. Les différentes variables associées aux grandes cultures et à l'élevage sont bien représentées et ont une forte contribution dans la variance du jeu de données. Les statistiques liées à la part d'STH, de prairies, de SFP et d'OTEX polyculture élevage sont corrélées et sont opposées aux variables associées aux grandes cultures (proportion des surfaces de céréales/SAU et OTEX grandes cultures). 
- L'axe 2 représente `r round(res.pca$eig[2,2])`% de l'information. La correlation avec les variables est moins nette que l'axe 1. Les variables de type climat et topographie sont légèrement correlées à cet axe. D'autres variables d'occupation du sol sont associées à l'axe 2. Celles-ci concernent les zones agricoles hétérogènes ($clc_25_90$), les zones de maïs fourrage et les zones qui ont une densité importante en UGBTA. Logiquement, ces deux dernière variables sont liées.

* Les variables liées à Corine Land Cover ont un faible impact dans l'espace de corrélation. Etant donné qu'elle représente une information similaire aux données du recencement agricole, elle sont éliminées du jeu d'analyse par la suite.*

Dans cet espace, la teneur en carbone organique initiale (période 90-94) est moyennement représentée (-50% de contribution). Cette variable est directement opposée aux variables climatiques ce qui met en valeur l'importance de ce facteur dans la distribution spatiale des teneurs à l'échelle de la France.
Dans une moindre mesure, la teneur en CO est correlée aux surfaces fourragères principales et aux UGBTA.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=8,fig.cap = fig$cap("pca_fr",""),fig.align="center"}
pca
# revoir cette discussion sur l'intérêt de la PCA pour la sélection des variables. A titre de conclusion, c'est assez intéressant.http://stats.stackexchange.com/questions/27300/using-principal-component-analysis-pca-for-feature-selection
```
## Test d'endogénéité des variables d'occupation du sol

L'objectif de cette partie est d'évaluer l'ensemble l'endogénéité des variables d'occupation du sol.

- p_prairie1970
- p_sfp1970
- p_sth1979
- p_sth1988
- p_cop1979
- p_c1979

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
# selon http://eclr.humanities.manchester.ac.uk/index.php/IV_in_R

library(AER)
#endo <- c("p_prairie1970","p_sfp1970","p_sth1979","p_sth1988","p_cop1979","p_c1979")
endo <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
exo <- c("altimean","hpluie_an","jchauds_an","jfroids_an","pluie_ecart_janv","std_pluie_juil","std_temp_janv","std_temp_juil","argi_med","sabt_med")
exoplus <- paste(exo,collapse="+")
variamodel <- c(endo,exo)

instru <- c("corgox1014","corgox0509")
instruplus <- paste(instru,collapse="+")

vNames <- unique(c("corgox9599",instru,variamodel))
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]

# Test des instruments

first_stage <- lm(educ~age+exper+expersq+fatheduc+motheduc,data=mydata)
instrFtest <- waldtest(first_stage,.~.-fatheduc-motheduc)
print(instrFtest)


# Test de l'endogénéité
intrutest <- list()
HausWu <- list()
for(i in endo){
  varia <- variamodel[!variamodel %in% i]
  first_stage <- lm(paste(i, " ~ ", paste(c(exoplus,instruplus),collapse="+"),sep=""),data=d)
  #instrHausWutest <- waldtest(first_stage,.~.-paste(instru,collapse="-"))
  instrHausWutest <- waldtest(first_stage,.~.-corgox1014-corgox0509)
  intrutest[[i]] <- instrHausWutest[2,4]

  Hausman_reg <- lm(paste(vNames[1], " ~ ", paste(varia,collapse="+"),"+first_stage$residuals",sep=""),data=d)
  HausWutest <- waldtest(Hausman_reg,.~.-first_stage$residuals)
 HausWu[[i]] <- HausWutest[2,4]
}

cbind.data.frame(melt(intrutest),melt(HausWu))
```

## Sélection des variables d'intérêt

L'objectif de cette partie est de sélectionner les principales variables explicatives et d'étudier l'effet des variables d'origines anthropiques sur un modèle linéaire des teneurs en CO. Pour cela, l'algorithmme suivant est appliqué :

- 1 : Pour chaque type de variables explicatives (naturelle et anthropique), application d'un modèle linéaire avec sélection du meilleur modèle sur le critère AIC. La méthode utilisée pour construire les modèles est basé sur le stepwise/backward (fonction stepAIC).
- 2 : Extraction des meilleurs modèles et calcul du R2 non-ajusté
- 3 : Construction d'un modèle linéaire basé sur les variables anthropiques et naturelles précédemment sélectionnés. Calcul du R2 non-ajusté et comparaison avec les modèles linéaires anthropiques et naturelles.

```{r,eval=FALSE,echo=FALSE,message=FALSE,warning=FALSE}
#library(relaimpo)
#library(earth)

# Sélection des variables de travail
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")

Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")

# Lancement de la fonction pour calculer le R2 des différentes types de variables
p <- list()
lmcpl <- list()
formule <- list()

for(i in Variay){
  Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop)
  vNames <- c(i,Rcovar)
  d2 <- dcast.bdat[complete.cases(dcast.bdat[,vNames]),vNames]
  plm <- lm_variatype(d2,Rnaturel,Ranthrop,i)
  
  p[[i]] <- plm$df[1:2]
  lmcpl[[i]] <- plm$lmcplt
  formule[[i]] <- plm$df[1:3]
}

save(p,file=paste(repsortie,"p_lm_variatype.RData",sep=""))

#formulecplt <- as.character(formule[[1]][formule[[1]]$nom %in% "Complet",3])
#vNamescplt <- c("corgox9599",str_split(formulecplt,"\\+")[[1]])
#formulecplt2 <- as.formula(paste("corgox9599~",formulecplt,sep=""))
#d2 <- dcast.bdat[complete.cases(dcast.bdat[vNamescplt]),vNamescplt]
#stepcplt <- stepAIC(lm(formulecplt2,data=d2),data=d2)

#lmMod <- lm(stepcplt)  # fit lm() model
#relImportance <- calc.relimp(lmMod, type = "lmg", rela = TRUE)  # calculate relative importance scaled to 100

#test <- earth(formulecplt2,data=d2)
#ev <- evimp(test) # estimate variable importance
#plot(ev)

```
Les résultats de ces tests sont présentés dans le tableau ci-dessous. Pour l'ensemble des teneurs en CO modélisé, la part des variables de types anthropiques est toujours la plus faible. Elle se situe entre 5 et 7% pour les (voir deuxième tableaux ci-dessous). La part des variables naturelle (topographie, pédologie et climat) est bien plus importante. 

```{r summaryR2ml_fr,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',message=FALSE,warning=FALSE}
load(paste(repsortie,"p_lm_variatype.RData",sep=""))
p2 <- melt(p)
colnames(p2) <- c("Type_variable","Indicateur","R2_nonajusté","Teneur_CO")
pander(p2[,c("Teneur_CO","Type_variable","R2_nonajusté")])

p3 <- list()
for(i in as.factor(unique(p2["Teneur_CO"])[[1]])){
  p3[[i]] <- round((p2[p2$Teneur_CO %in% i,][3,"R2_nonajusté"]-p2[p2$Teneur_CO %in% i,][2,"R2_nonajusté"])*100,2)
}
p3 <- as.data.frame(p3)
pander(p3,caption="Contribution (en %) des variables anthropiques dans la modélisation des teneurs en carbone organique pour les différentes périodes")
```

## Modèle de fouille de données

Dans cette partie, on testera rapidement deux modèles de fouille de données utilisés dans plusieurs travaux sur les sols (voir [Murciano et al., 2015](http://www.afes.fr/afes/egs/EGS_22_1_2201_09_18murciano_final.pdf) pour une description des modèles)

- GBM : Le principe de cet algorithme est de construire une séquence de modèles afin qu’à chaque
étape, chaque modèle ajouté à la combinaison apparaisse comme un pas vers une meilleure solution.
- Cubist : Cubist est un modèle de régression axé prédiction qui combine les idées de modèle à base de règles, décrites dans Quinlan (1992) avec des corrélations supplémentaires basées sur les voisins les plus proches dans l'ensemble d’apprentissage (voir Quinlan (1993) pour plus de détails).

### Comparaison des modèles (GBM et Cubist)

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}

##### Préparation des données pour la modélisation############################################
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

Rcovaroccup <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")

typeoccup <- replicate(length(Rcovaroccup), "occup")

type <- c(typetopo,typepedo,typeoccup,typeclimato)
Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)

# Construction du vecteur des variables du modèle. 
vNames <- c("corgox9599",Rcovar)

# Sélection du jeu de données
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
#############################################################################################

# Paramètres de modélisation
trControl <- trainControl(method = "cv",p=0.8,number=10)
tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

# 
datax <- d[, vNames[-1]]
datay <- d[, vNames[1]]

# On lance caret pour les deux types modèles (voir https://github.com/tobigithub/caret-machine-learning/blob/master/caret-parallel/run-multiple-caret-models-parallel-lapply.R)

modelObjects <- list()
model <- c("gbm","cubist")
for(i in 1:length(model)){
  print(model[i])
  modelObjects[[model[i]]] <- train(x = datax, y = datay,model[i],tuneGrid = tuneGrid[[i]],trControl = trControl,verbose = F,keep.data = T)
  }

# Sauvegarde
save(modelObjects,file=paste(repsortie,"modelObjects.RData",sep=""))

#modelObjects <- list()
#model <- c("gbm","cubist")

#m <- c("gbm","cubist")
#t2 <- lapply(m,function(x) {set.seed(123); seeds <- vector(mode = "list", length = nrow(datax) + 1); seeds <- lapply(seeds, function(x) 1:20); t1 <- train(datax, datay, (x),trControl = trainControl(method = "cv",seeds=seeds))})
#r2 <- lapply(1:length(t2), function(x) {cat(sprintf("%-10s",(m[x])));cat(t2[[x]]$results$Rsquared[which.min(t2[[x]]$results$RMSE)],"\t"); cat(t2[[x]]$results$RMSE[which.min(t2[[x]]$results$RMSE)],"\n")})
```
```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,error=FALSE}
load(paste(repsortie,"modelObjects.RData",sep=""))
resamps <- resamples(modelObjects)
```
Ci-dessous, la figure et les tableaux présentent les résultats de la qualité de la prédicition des deux modèles sur les 10 validations croisées. Le modèle cubist présente de meilleurs résultats que le modèle gbm. Pour la précision du modèle, la médiane de la racine quarré de l'erreur quadratique moyenne du modèle cubist est de `r median(summary(resamps)$values[,"cubist~RMSE"])` tandis qu'elle est de `r median(summary(resamps)$values[,"gbm~RMSE"])` pour gbm. Les coefficients de détermination entre les deux modèles sont quasiment identique, avec un légèr avantage pour le modèle cubist.
**Le modèle Cubist sera utilisé par la suite.**

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,error=FALSE}
pander(summary(resamps)$statistics,caption="Statistiques des résultats de la validation croisée pour les modèles gbm et cubist")
p1 <- dotplot(resamps)
p2 <- parallelplot(resamps, metric = "Rsquared")
grid.arrange(p1,p2,nrow=1)
```

### Application du meilleur modèle Cubist

Ci-dessous, la modélisation avec Cubist est relancé selon l'algorithme suivant :

```{r engine='bash',eval=FALSE,}
1. Définition des paramètres de modélisation
   - Validation croisée sur les différents paramètres de modélisation (10 fois)
   - Sélection des meilleurs paramètres
2. Application du modèle avec les meilleurs paramètres (100 fois)
   - Sélection aléatoire de 80% du jeu de données pour l'apprentissage et 20% pour la validation
   - Construction du modèle sur 80% du jeu de données
   - Calcul de l'importance des variables dans le modèle
   - Prédiction sur 20% du jeu de données et comparaison avec le jeu de données initial
   - Calcul des indicateurs de qualité (R2, MSE, RMSE)
3. Calcul de la moyenne des indicateurs sur les 100 répétitions
   - Calcul de la moyenne des indicateurs de qualité sur le nombre de répétition
   - Calcul de l''importance moyenne des variables pour le nombre de répétition
```

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}
#http://stackoverflow.com/questions/24779363/return-variable-importance-for-each-iteration-in-caret-package-in-r

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

## Construction des variables occupation du sol en fonction de la période en C étudiée
periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("elevage1988","elevagehorsol1988","polyelevage1988","ugbta1988","grdcultures1988")
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

nbr <- 100
prob <- 0.8
model="cubist"
cpt <- 0

for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  # Suppression p_protea1970 (inexistant en 1970!)
  #ra_occupyears <- ra_occupyears[!ra_occupyears %in% "p_protea1970"]

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)

  # Construction du vecteur des variables du modèle. 
  vNames <- c(i,Rcovar)

  # Sélection du jeu de données
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]

  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))
    
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
  datax <- d[,vNames[-1]]
  datay <- d[,vNames[1]]

  #library(debug)
  #debug(cv_datamining)
  #mtrace("cv_datamining")
  
  mcubist_fr <- cv_datamining(datax,datay,nbr=nbr,prob,model,select=1:15,tuneGrid,trControl,repsortie)
  saveRDS(mcubist_fr,file=paste(repsortie,"mcubist_fr_",i,".rds",sep=""))
}
```
```{r,eval=TRUE,echo=FALSE}
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")

impvar <- list()
p <- list()
rest <- array(NA, dim = c(length(Variay), 3),list(Period_co = Variay, mod = c("r2","MSE","RMSE")))
cpt <- 0
for(i in Variay){
  cpt <- cpt + 1
  namemodel <- paste("mcubist_fr_",i,sep="")
  assign(namemodel,readRDS(paste(repsortie,namemodel,".rds",sep="")))
  p[[cpt]] <- get(namemodel)$p + labs(title=i)

  rest[cpt,"r2"] <- get(namemodel)$qualityindex[,"R2"][[1]]
  rest[cpt,"MSE"] <- get(namemodel)$qualityindex[,"MSE"][[1]]
  rest[cpt,"RMSE"] <- get(namemodel)$qualityindex[,"RMSE"][[1]]
  impvar[[i]] <- get(namemodel)$varimport
}
```
Les résultats de la validation croisée de la modélisation des teneurs en CO pour les différentes périodes sont présentés dans le tableau ci-dessous. Sur les 100 répétitions, l'application du modèle sur les 20% du jeu d'apprentissage montre une capacité de prédiction des teneurs en CO équivalente entre les périodes et de bonne qualité. La modélisation des teneurs en CO pour la période 2010-2014 montrent la capacité de prédiction la plus mauvaise avec un coefficient de détermination (R2) de 0.78 et un erreur moyenne (Root Mean Square Error) de 2.4 g/kg. La période 2000-2004 affiche les meilleurs avec un R2 de 0.83 et une erreur moyenne de 2.2 g/kg. En moyenne la modélisation des teneurs en CO toute période confondues affiche donc une capacité d'explication de la variance de plus de 80%.

```{r,eval=TRUE,echo=FALSE}
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée pour les différents modèles")
```
Les 15 variables explicatives de ces modélisations sont présentées dans la figure ci-dessous. Le taux d'argile (`argi_med`) et l'écart de pluie à la moyenne en janvier (`pluie_ecart_janv`) sont les deux premières variables explicatives des 4 modèles. Elles présentent toutes deux un pourcentage d'importance supérieur à 50%. L'altitude moyenne (`altimean`) par canton et le pourcentage de surface fourragère principale (pour différentes périodes) (`p_sfp`) sont également des variables explicatives d'importance. 

Cette dernière variable est quasiment présente sous toutes ces déclinaisons temporelles (1970, 1979, 1988, 2000, 2010). Dans une moindre mesure, le pourcentage de prairie dans la SAU et le pourcentage de maïs fourrage sont les autres variables de type occupation du sol qui ressortent régulièrement dans ce classement des 15 variables explicatives les plus importantes.

L'ordre d'importance des variables explicatives des 4 périodes des teneurs en CO ne sont pas complètement identique à défaut de la première variables explicatives (l'argile). Toutefois, on note de nombreuses similitude entre les 3 premiers modèles (1995-1999 à 2005-2009). La dernière modélisation (2010-2014) présente des résultats différents, avec une part de variable d'origine climatique plus importante.

```{r,eval=TRUE,echo=FALSE}
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

> **En conclusion** Ces résultats montrent que la répartition des teneurs en CO de la BDAT à l'échelle de la France est principalement expliquée par des variable d'origine naturelle (pédologique, climatique, et topographique). L'effet de l'occupation du sol apparaît secondaire. Ces résultats concordent avec les premières conclusions du travail de la modélisation avec des régressions linéaires multiples effectuées avec des co-variables naturelles ou d'origine anthropiques. A la suite de ce premier travail, la modélisation des teneurs en CO doit être reconduite à l'échelle d'un zonage où le contexte climatique, pédologique et topographique est homogène afin d'identifier les variables d'occupation du sol susceptibles d'agir sur les teneurs en CO.

```{r,eval=FALSE,echo=FALSE}
# Construction de la grille 
grille <- expand.grid(argi_med = quantile(d[,"argi_med"], c(seq(0,0.9,0.1),0.98)), 
                      pluie_ecart_janv = quantile(d[,"pluie_ecart_janv"],c(seq(0,0.9,0.1),0.98)),
                      altimean = quantile(d[,"altimean"],c(seq(0,0.9,0.1),0.98)),
                      p_sfp1979 = quantile(d[,"p_sfp1979"],c(seq(0,0.9,0.1),0.98)))

autre <- vNames[!(vNames %in% c("argi_med","pluie_ecart_janv","p_sfp1979","altimean"))][-1]

variaeffect(grille = grille,vNames = autre,data = d,model = mcubist,nameModel = "cubist",neighbors=tuneGrid,nomsortie="test",sortie=repsortie)
```

### Test sur un modèle globale

```{r,eval=FALSE}

variable <-  c("value","code_reg","nom_region","typo_clim","zonage_simple","zonage_cplt","classe_altimean","mat11","classe_p_sth1970","classe_p_sfp1970","classe_p_prairie1970","classe_p_cop1970","classe_p_c1970","classe_p_sth1979","classe_p_sfp1979","classe_p_prairie1979","classe_p_cop1979","classe_p_c1979","classe_p_sth1988","classe_p_sfp1988","classe_p_prairie1988","classe_p_cop1988","classe_p_c1988","classe_p_sth2000","classe_p_sfp2000","classe_p_prairie2000","classe_p_cop2000","classe_p_c2000","classe_p_sth2010","classe_p_sfp2010","classe_p_prairie2010","classe_p_cop2010","classe_p_c2010","annees")
vNames <- variable

d <- dm_traitements.melted_bdat_9514[,]



```






# Analyse par stratification

Cette section reprend le travail de modélisation réalisé précédemment en l'appliquant à l'échelle des strates liée au type de climat et aux principales régions d'élevage.

## Analyse linéaire par stratification

Attention, dans les résultats, revoir le calcul car valeur R2 abérante. Prendre en compte la différences dans le nombre d'échantillon par strates.

```{r lmstratification_climat,eval=FALSE,echo=FALSE}
# Sélection des variables de travail
strates <- levels(as.factor(dcast.bdat$typo_clim))

# Co-variables
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")
Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
Variay <- "corgox9599"

Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop)
vNames <- c(Variay,Rcovar)

p <- list()

d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),]

for(i in strates){
  print(i)
  d_typo <- d[d$typo_clim %in% i,vNames]
  p[[i]] <- lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2]
}

#
lm_climato <- as.data.frame(p)
to <- paste("X",1:7,sep="")
from <- replicate(7, "Type")
colnames(lm_climato)[grep("nom",names(lm_climato))] <- gsub2(lm_climato[grep("nom",names(lm_climato))],to,from)
#
to <- paste("X",1:7,".R2",sep="")
from <- paste("Clim",1:7,sep="")
colnames(lm_climato)[grep("R2",names(lm_climato))] <- gsub2(lm_climato[grep("R2",names(lm_climato))],to,from)
lm_climato <- melt(lm_climato,id="Type")
```

```{r lmstratification_elevage,eval=FALSE,echo=FALSE}
# Stratification par zonage des grandes régions d'élevage
strates <- levels(as.factor(dcast.bdat$zonage_cplt))
length(strates)
p <- list()

# Co-variables
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")
Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","p_mf1988","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
Variay <- "corgox9599"

Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop)
vNames <- c(Variay,Rcovar)

p <- list()
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),]

for(i in strates){
  print(i)
  d_typo <- d[d$zonage_cplt %in% i,vNames]
  #p[[i]] <- lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2]
  
  ptry <- try(lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2],silent=TRUE)

   if(class(ptry)[1]=="try-error"){
    print("Pas assez d'échantillons pour la modélisation")
    next
  }else{
    p[[i]] <- ptry
  }
}

#
lm_regelevage <- as.data.frame(p)
strates2 <- strates[!(strates %in% "F2")]
to <- paste(strates2,".nom",sep="")
from <- replicate(length(strates2), "Type")
colnames(lm_regelevage)[grep("nom",names(lm_regelevage))] <- gsub2(lm_regelevage[grep("nom",names(lm_regelevage))],to,from)
#
to <- paste(strates2,".R2",sep="")
from <- strates2
colnames(lm_regelevage)[grep("R2",names(lm_regelevage))] <- gsub2(lm_regelevage[grep("R2",names(lm_regelevage))],to,from)
lm_regelevage <- melt(lm_regelevage,id="Type")
```

## Analyse Cubist par stratification

L'application de la modélisation avec Cubist pour les différentes strates géographiques suit l'algorithme suivant :

```{r eval=FALSE}
Pour chaque strate :
  1. Définition des paramètres de modélisation
    - Validation croisée sur les différents paramètres de modélisation (10 fois)
    - Sélection des meilleurs paramètres
  2. Application du modèle avec les meilleurs paramètres (100 fois)
    - Sélection aléatoire de 80% du jeu de données pour l'apprentissage et 20% pour la validation
    - Construction du modèle sur 80% du jeu de données
    - Calcul de l'importance des variables dans le modèle
    - Prédiction sur 20% du jeu de données et comparaison avec le jeu de données initial
    - Calcul des indicateurs de qualité (R2, MSE, RMSE)
  - Calcul de la moyenne des indicateurs de qualité sur le nombre de répétition
  - Calcul de l''importance moyenne des variables pour le nombre de répétition
Fin
```
  
### Stratification par type de climat

```{r cubiststratification,eval=FALSE,echo=FALSE}
strates <- 1:5
prob <- 0.8
nbr <- 100
impvar <- list()
p <- list()
rest <- array(NA, dim = c(length(strates), 3),list(strates = strates, mod = c("r2","MSE","RMSE")))
model <- "cubist"

cpt <- 0
for(i in strates){
  cpt <- cpt + 1
  print(i)
  d_typo <- dcast.bdat[complete.cases(dcast.bdat[vNames]) & dcast.bdat$typo_clim %in% i,vNames]
  
  datax <- d_typo[, vNames[-1]]
  datay <- d_typo[, vNames[1]]
 
  # Paramètres de modélisation
  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

  # Modélisation avec les meilleurs paramètres
  mcubistbst <- cv_datamining(datax,datay,nbr=nbr,prob,model,tuneGrid,trControl,repsortie,select=1:15)

  rest[cpt,"r2"] <- mcubistbst$qualityindex[,"R2"][[1]]
  rest[cpt,"MSE"] <- mcubistbst$qualityindex[,"MSE"][[1]]
  rest[cpt,"RMSE"] <- mcubistbst$qualityindex[,"RMSE"][[1]]
  
  p[[cpt]] <- mcubistbst$p + labs(title=i)
  impvar[[i]] <- mcubistbst$varimport
}



do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=3,position="bottom")))

ggplot(impvar$G2, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(stat = "identity") + coord_flip() + labs(title=i)


ggplot(impvar$G2, aes(x = variable, y = importance,fill=type)) + 
  geom_bar(position="fill") + coord_flip() + labs(title=i) + coord_polar("y")

save(impvar,file=paste(repsortie,"impvarcubist_typoclim.RData",sep=""))
save(p,file=paste(repsortie,"pcubist_typoclim.RData",sep=""))
save(rest,file=paste(repsortie,"restcubist_typoclim.RData",sep=""))
```
Sur les 3 strates climatiques modélisées, les tests de modélisation présentent des r2 de 

Le rôle des variables explicatives est différent. Pour les zones 3 et 4, le taux d'argile joue un rôle prépondérant et les variables 

Dans la zone climatique 5, les variables climatiques sont nettement plus contributrices du modèle que les variables d'occupation du sol. 

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=12, fig.width=12,fig.cap = fig$cap("cubist_strat_fr","Importance des variables explicatives"),fig.align="center",message=FALSE,warning=FALSE,results = 'asis'}
load(paste(repsortie,"pcubist_typoclim.RData",sep=""))
load(paste(repsortie,"restcubist_typoclim.RData",sep=""))
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée")
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))
```

### Stratification par grande région d'élevage

```{r gbmstratificationelevage,eval=FALSE,echo=FALSE}
reg_elevage <- c("A","B1","B2","C1","D","E1","E2")

p_regelevage <- list()
impvar <- list()
rest <- array(NA, dim = c(length(reg_elevage), 3),list(strates = reg_elevage, mod = c("r2","MSE","RMSE")))
nbr <- 100
prob <- 0.8
cpt <- 0

for(i in reg_elevage){
  cpt <- cpt + 1
  print(i)
  
  d_typo <- dcast.bdat[complete.cases(dcast.bdat[vNames]) & dcast.bdat$zonage_cplt %in% i,vNames]
  
  datax <- d_typo[, vNames[-1]]
  datay <- d_typo[, vNames[1]]
 
  # Paramètres de modélisation
  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

  # Modélisation avec les meilleurs paramètres
  mcubistbst <- cv_datamining(datax,datay,nbr=nbr,prob,model,tuneGrid,trControl,repsortie,select=1:15)

  rest[cpt,"r2"] <- mcubistbst$qualityindex[,"R2"][[1]]
  rest[cpt,"MSE"] <- mcubistbst$qualityindex[,"MSE"][[1]]
  rest[cpt,"RMSE"] <- mcubistbst$qualityindex[,"RMSE"][[1]]
  
  p_regelevage[[cpt]] <- mcubistbst$p + labs(title=i)
  impvar[[i]] <- mcubistbst$varimport
}

save(impvar,file=paste(repsortie,"impvarcubist_elevage.RData",sep=""))
save(p_regelevage,file=paste(repsortie,"pcubist_elevage.RData",sep=""))
save(rest,file=paste(repsortie,"restcubist_elevage.RData",sep=""))
```
Ci-dessous, commenter les résultats de la stratification avec les principales régions d'élevage

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=12, fig.width=12,fig.cap = fig$cap("cubist_strat_elevage","Importance des variables explicatives"),fig.align="center",message=FALSE,warning=FALSE,results = 'asis'}

load(paste(repsortie,"pcubist_elevage.RData",sep=""))
load(paste(repsortie,"restcubist_elevage.RData",sep=""))
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée")
do.call(grid_arrange_shared_legend,c(p_regelevage,list(nrow=3,ncol=3,position="bottom")))

```
