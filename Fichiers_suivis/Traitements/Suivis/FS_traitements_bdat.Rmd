---
title: "Analyse des teneurs en carbone organique de la BDAT"
author: "Jean-Baptiste Paroissien"
date: "20/03/2017"
output:
  html_document:
    toc: yes
    toc_float: yes
    fig_caption: yes
    highlight: kate
    number_sections: yes
    theme: spacelab   
---

```{r setup, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
# Importation des paramètres de travail
source("/media/sf_GIS_ED/Dev/Scripts/master/Fonctions/R/importparametres.R")
repmaster <- "/media/sf_GIS_ED/Dev/Scripts/master/"
importparametres(repmaster=repmaster,repdata="/media/sf_GIS_ED/Dev/Data/",dsn="PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'")
repsortie <- paste(repmaster,"Fichiers_suivis/Traitements/Fichiers/",sep="") #répertoire de sortie pour des différents fichiers

set.seed(157) #Pour la reproductibilité
cl <- makeCluster(4);registerDoParallel(cl) #Configuration pour le calcul en parallèle
```

```{r,eval=TRUE,echo=FALSE}
## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    
```

```{r date, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE,eval=TRUE}
date <- Sys.Date()
sessionInfo()
```

```{r, tidy=FALSE,eval=TRUE,echo=FALSE}
mo_url <- "https://github.com/GisEDSol/Carbo_elevage/tree/master/Documentation/Modes_operatoires/"
fs_url <- "https://github.com/GisEDSol/Carbo_elevage/tree/master/Fichiers_suivis/"
raw_mo_url <- "https://rawgit.com/GisEDSol/Carbo_elevage/master/Documentation/Modes_operatoires/"
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Jeu de données sur 4 périodes de temps
bdat9514 <- sqlQuery(loc,paste("select * from dm_vecteurs.canton_9514",sep=""))
melted.9514 <- sqlQuery(loc,paste("select * from dm_traitements.melted_bdat_9514"),stringsAsFactors=TRUE,as.is=TRUE)
melted.9514$value <- as.numeric(melted.9514$value)
melted.9514 <- melted.9514[complete.cases(melted.9514$value),]
melted.9514$annees <- factor(melted.9514$annees,levels=c("9599","0004","0509","1014"))

# Sélection des teneurs mesurées avec la méthode OX (médiane)
dcast.bdat <- bdat9514
melted.bdat <- melted.9514 

# Sélection uniquement des médianes et du 3ème quartile
melted.bdat <- melted.bdat[melted.bdat$variable %in% c("med_corgox","dqua_corgox"),]
levels(melted.bdat$variable) <- c("Médiane","75% centile")

# En attendant les corrections de Laetitia, on travaille sur les médianes
melted.bdat <- melted.bdat[melted.bdat$variable %in% "med_corgox",]

```

# Objectifs

L'objectif de ce travail est d'analyser la distribution statistiques et géographiques des teneurs en Carbone Organique (CO) de la BDAT pour les 5 périodes de temps suivantes : 1990-1994, 1995-1999, 2000-2004, 2005-2009 et 2010-2014. Dans un premier temps, le travail est porté à l'échelle de la France afin d'appréhender globalement les différences entre les périodes de temps. Le même travail est ensuite reconduit sur différentes strates géographiques pour affiner les résultats sur différentes échelles géographiques. Enfin, la troisième étape propose d'analyser la répartition spatiale des teneurs avec des facteurs explicatifs potentiels. 

Les résultats présentés font suite à différents scripts de préparation de données dont la chaîne de traitements générale est consultable à cette [adresse](`r raw_mo_url`Figures/workflow.html).

# Analyse des teneurs en carbone organique par période (France)

Cette première étape a pour but d'analyser les teneurs en CO de la BDAT pour chacune des périodes de temps analysées. La cartographie des teneurs en CO est présentée dans un premier temps et les statistiques descriptives (courbes de fréquences cumulées et boxplot) sont présentées dans un second temps.

## Représentation cartographique

### Cartographie des effectifs de la BDAT

La cartographie du nombre d'analyse de la BDAT par canton pour les teneurs en CO est présentée dans la figure ci-dessous. Cette figure met en évidence une importante variabilité spatio-temporelle du nombre d'analyse. De façon générale (toutes périodes confondues), le nombre d'effectif est plus important sur la partie nord et ouest du pays. Le Massif Central et le Sud-Est sont faiblement concentrés en effectifs.

Les variabilité sont également marquées dans le temps. La période 9094 ne comporte pas d'analyse dans plusieurs régions comme la Normandie. Les autres périodes présentent une distribution des analyses plus stables.

> **Compte-tenu du manque de données observée dans la première période 9094, celle-ci ne sera pas prise en compte dans les analyses des teneurs en CO à l'échelle de la France.** 

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
# Paramètres #################
tablecarto <- "dm_vecteurs.canton" #Nom de la table utilisée pour la cartographie (table postgis)
variable <- "eff_corgox_"
period <- c("9094","9599","0004","0509","1014") #
variablecarto <- paste(variable,period,sep="")#variables à cartographier
nclasse <- 5 
style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
couleur <- brewer.pal(5,"YlOrRd") #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
l_variable <- "Nombre d'échantillon par canton" #label de la variable
nomfichier <- "effectif_bdat_corgox" #Nom du fichier

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,title=c("1990-1994","1995-1999","2000-2004","2005-2009","2010-2014"),caption="",dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=3,position="bottom",ggsaveheight=7,ggsavewidth=9.2)
```

```{r carto_effectif_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"effectif_bdat_corgox.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Cartographie des teneurs en carbone organique (CO)

La cartographie des teneurs en CO de la BDAT est présentée dans les figures ci-dessous. Celle-ci est réalisée uniquement sur les 4 dernières périodes (9599, 0004, 0509, 1014) et appliquée sur un masque pour analyser les teneurs sur un nombre de canton commun entre les périodes.

La cartographie montre une distribution spatiale organisée et globalement similaire pour les différentes périodes analysées. De façon générale, cette organisation suit la lithologie du pays avec de fortes teneurs en carbone organique présentes dans les zones de socles et de piemonds et des valeurs plus faibles dans les principaux bassins sédimentaires (parisien et aquitain).

```{r ,highlight=TRUE,eval=FALSE,echo=FALSE}

tablecarto <- "dm_vecteurs.canton_9514" #Nom de la table utilisée pour la cartographie (table postgis)
period <- c("9599","0004","0509","1014") #
stats <- c("med","dqua")

for(i in stats){
  variablecarto <- paste(i,"_corgox_",period,sep="")
  #variables à cartographier
  nclasse <- 5 
  style_classe <- "quantile"#Nombre de classes de valeurs pour la cartographie
  couleur <- brewer.pal(nclasse,"YlOrRd") #Nom de la palette couleur (selon RColorBrewer)display.brewer.all() pour connaître les différentes palettes
  l_variable <- "Teneur en carbone organique (g/kg)" #label de la variable
  nomfichier <- paste("corgox_period_2",i,sep="") #Nom du fichier
  titleperiod <- c("1995-1999","2000-2004","2005-2009","2010-2014")
  title <- paste(i,"_",titleperiod,sep="")
  
  carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_variable,repsortie,nomfichier,title=title,caption="",dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=2,position="bottom",ggsaveheight=7,ggsavewidth=6.27)
}

```
```{r carto_c_fr, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"corgox_period_fr.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

## Statistiques descriptives

La figure `r fig$ref("cdf_fr",link=TRUE)` présente les courbes de fréquences cumulées des teneurs en carbone organique distribuées pour les 4 périodes identifiées. Les courbes de fréquences des 4 périodes présentent la même forme en "S" et s'individualisent juste avant le plateau, présentant une différence affectant les sols riches en teneurs organiques (entre 17 et 45 g/kg). Sur cette zone (figure à droite), la figure montre un décalage des courbes des périodes 2000-2004, 2005-2009 et 2010-2014 vers des valeurs plus faibles. Parmi ces 3 périodes, la période 2005-2009 est celle qui se décale le plus vers des teneurs plus faible tandis que la période 2010-2014 se rapproche des valeurs de 1995-1999, présentant ainsi une inversion de la tendance observée.

**Ces observations mettent en évidence une diminution des teneurs en carbone entre les périodes 1990-1999 et 2000-2009 et une légère augmentation pour la période 2010-2014.**


```{r cdf_fr,highlight=TRUE,echo=FALSE,eval=TRUE,warning=FALSE,error=FALSE,fig.height=5, fig.width=7,fig.cap = fig$cap("cdf_fr","Courbe de fréquences cumulées"),fig.align="center"}

period <- c("9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"
ylabel <- "Fréquence"
nperiod <- length(period)
colors <- brewer.pal(nperiod,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

p <- list()
# Courbe de fréquence cumulée
p[[1]] <- ggplot(melted.bdat[melted.bdat$variable %in% "med_corgox",], aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme_perso()

#ggsave(p[[1]],file = paste(repsortie,"cdf_fr1.png",sep=""), width = 9, height = 7)  
p[[2]] <- ggplot(melted.bdat[melted.bdat$variable %in% "med_corgox" & (melted.bdat$value > 17) & (melted.bdat$value < 45) ,], aes(x=value))+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=colors, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme_perso()

#ggsave(p[[2]],file = paste(repsortie,"cdf_fr2.png",sep=""), width = 9, height = 7)  

tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))
#ggsave(tt,file = paste(repsortie,"cdf_fr.pdf",sep=""), width = 10, height = 7)  
```

```{r ,echo=FALSE,eval=TRUE,results='asis',fig.height=10, fig.width=10,fig.align="center"}
p <- list()
bdatsummarystats <- list()
for(i in levels(as.factor(melted.bdat$variable))){
  melted.test <- melted.bdat[melted.bdat$variable %in% i,]
  # Résumé des statistiques 
  bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
  bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
  bdatsummarystats[[i]] <- bdatsummary

  pander(bdatsummary,caption="Stastistiques descriptives des teneurs en CO pour les différentes statistiques aggrégées à l'échelle cantonale")

# Changer le nom des variables (pour améliorer la compréhension)
  datasummary <- as.data.frame(bdatsummary$value[,"Median"])
  colnames(datasummary) <- "median"
  datasummary <- t(datasummary)
  colnames(datasummary) <- c("1995-1999","2000-2004","2005-2009","2010-2014")

  res <- outer(1:ncol(datasummary), 1:ncol(datasummary), 
              function(x,y) ((datasummary[,x]-datasummary[,y])/datasummary[,x])*100)

  period_count <- c(1995,2000,2005,2010)

  res_period <- outer(1:length(period_count), 1:length(period_count), 
              function(x,y) ((period_count[x])-period_count[y]))

  res[upper.tri(res, diag = TRUE)] <- NA
  res2 <- res/res_period
  colnames(res2) <- as.character(colnames(datasummary))
  rownames(res2) <- as.character(colnames(datasummary))
  
  datasummary2 <- melt(res2)
  datasummary2 <- datasummary2[complete.cases(datasummary2$value),]

  datasummary2$count <- c("23","24","25","34","35","45")

  colnames(datasummary2) <- c("EndDate","StartDate","Group","Count")

 # Ajout du test statistiques (wilcoxon)
 res.wilcoxon <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])$p.value
 res.wilcoxon[upper.tri(res.wilcoxon, diag = FALSE)] <- NA
 colnames(res.wilcoxon) <- as.character(c("1995-1999","2000-2004","2005-2009"))
 rownames(res.wilcoxon) <- as.character(c("2000-2004","2005-2009","2010-2014"))
 res.wilcoxon <- melt(res.wilcoxon,na.rm=TRUE)
    
 # Ajout du test vers bdatmedian2
 datasummary2$pvalue <- res.wilcoxon$value
 datasummary2$value <- datasummary2$Group

# changer les codes couleurs+calculer les taux par années
  p[[i]] <- ggplot(datasummary2, aes(ymin = StartDate, ymax = EndDate, x = Count)) + geom_linerange(aes(colour=Group),size=3) + coord_flip() + scale_colour_gradient2(limit = c(-1,1),high=muted("green"),name="Taux d'évolution annuel (%)") + ylab("Périodes") + xlab("") + theme_perso() + geom_text(aes(y = StartDate, x = Count, label = ifelse(pvalue<=0.05,paste(round(value,1),"% **",sep=""),paste(round(value,1),"%",sep=""))), hjust = 0, vjust = 0.5, size = 3.5) + labs(title= paste(i))

}
tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))
tt

#############################################################################################
p[[i]] <- ggplot(datasummary2, aes(ymin = StartDate, ymax = EndDate, x = Count)) + geom_linerange(aes(colour=value),size=3) + coord_flip() + scale_colour_gradient2(limit = c(min(datasummary2$value),max(datasummary2$value)),low="orange",high=muted("purple"),name="Taux d'évolution annuel (%)") + ylab("Périodes") + xlab("") + theme_perso() + geom_text(aes(fontface=2,y = StartDate, x = Count, label = ifelse(pvalue<=0.05,paste(round(value,1),"% **",sep=""),paste(round(value,1),"%",sep=""))), hjust = 0, vjust = 0.5, size = 3.5) + labs(title= paste(i))

```

La distribution des teneurs en carbone organique par période est présentée figure `r fig$ref("boxplot_fr",link=TRUE)` et les statistiques associées dans le tableau ci-dessous. La tendance de diminution des teneurs observée dans la figure `r fig$ref("cdf_fr",link=TRUE)` est également constatée dans ces deux éléments. La période 2000-2004 montre la valeur médiane la plus faible avec une valeur de `r bdatsummary$value["0004","Median"]` g/kg. Les valeurs les plus importantes sont observées pour les périodes 1995-1999 et 2010-2014 avec des médianes de teneurs en carbone organique équivalente, à `r bdatsummary$value["9599","Median"]` g/kg. Ces évolutions sont très légèrement marquées sur la figure `r fig$ref("boxplot_fr",link=TRUE)` où l'évolution moyenne des teneurs en carbone organique baisse légèrement après la période 1995-1999.

```{r summarybdatfrancetable,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',warning=FALSE,message=FALSE}
pander(bdatsummarystats["med_corgox"][[1]],caption = "Statistiques descriptives des teneurs en carbone organique pour les différentes périodes")

pander(bdatsummarystats["75% centile"][[1]],caption = "Statistiques descriptives des teneurs en carbone organique pour les différentes périodes")
```

```{r boxplot_fr,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=5, fig.width=6,fig.cap = fig$cap("boxplot_fr","Boxplot des teneurs en carbone organiques par périodes"),fig.align="center",warning=FALSE,message=FALSE}

ylim1 <- c(min(melted.bdat$value,na.rm=TRUE),quantile(melted.bdat$value,0.95,na.rm=TRUE))

test1 <- generate_label_df(db=melted.bdat[melted.bdat$variable %in% "med_corgox",],value="value",lev="annees",LETTERS,position=1)
test2 <- generate_label_df(db=melted.bdat[melted.bdat$variable %in% "75% centile",],value="value",lev="annees",letters,position=1)

p <- ggplot(melted.bdat,aes(x=annees,y=value)) + 
     geom_boxplot(aes(x=annees,y=value,fill=variable))+
     stat_summary(fun.y=mean, geom="line",size = 1, aes(group=variable),alpha = 0.8) +
     scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone organique (g/kg)")+
     theme_perso(position="right")+ geom_text(data = test1,hjust = 2, vjust=-0.75,aes(x = plot.labels, y = V1, label = labels))+ geom_text(data = test2,hjust = -2,vjust=-0.75, aes(x = plot.labels, y = V1, label = labels))#+ coord_cartesian(ylim = ylim1)
p
```
Les résultats du test de Wilcoxon présentés ci-dessous montrent que **les différences des médianes cantonales à l'échelle de la France entre les périodes sont significatives pour la baisse observée entre les périodes 1995-1999 et 2000-2004, 1995-1999 et 2005-2009 et l'augmentation des teneurs entre les périodes [2000-2004 et 2010-2014]**. Ces résulats confirment les tendances observées sur les courbes de fréquences cumulées (voir figure `r fig$ref("cdf_fr",link=TRUE)`).

```{r,highlight=TRUE,eval=FALSE,echo=TRUE}
p <- list()
for(i in levels(as.factor(melted.bdat$variable))){
  melted.test <- melted.bdat[melted.bdat$variable %in% i,]
  
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
}
print(p)
```

## Conclusion

La médiane cantonale des teneurs en CO des analyses de la BDAT a évolué significativement entre les périodes étudiées (de 1995 à 2014). De 1995 à 2005-2009, la médiane des médianes des teneurs a diminué, passant de 14 g/kg à 13.70 g/kg. Cette tendance s'est inversée significativement entre les périodes 2000-2000 et 2010-2014 pour finalement revenir aux teneurs initiales de 1995-1999, à 14 g/kg. Au plus fort de ces évolutions,  la baisse médiane des médianes des teneurs en CO entre 1995-1999 et 2000-2004 est de %, soit environ une baisse annuelle de **% par an**. A l'inverse, on retrouve un taux d'augmentation plus faible entre les périodes 2000-2004 et 2010-2014 avec **% par an**.

Ces résultats sont comparables avec les travaux de [Bellamy et al., 2005](https://core.ac.uk/download/pdf/141023.pdf?repositoryId=23). Ces auteurs ont mis en évidence sur un ensemble d'analyses de sol réalisé en Angleterre et au Pays-de-Galles de 1978 à 2003 une baisse moyenne de teneurs en CO de **0.6% par an** (relatif par rapport aux teneurs initiales).

Ce travail d'analyse sur l'ensemble du territoire est reconduit sur plusieurs strates géographiques afin d'étudier les évolutions sur des compartiments environnementaux homogènes, du point de vue du climat et de l'occupation du sol.

# Analyse des teneurs en carbone organique par période et par différentes strates géographiques

L'analyse des teneurs en CO est appliquée à l'échelle de plusieurs de strates. Ces strates représentent des entités géographiques homogènes d'un point de vue climatique, du type d'élevage.
L'analyse par strate peut permettre d'observer des tendances régionales à l'intérieur desquelles les mécanismes d'évolution des teneurs en CO sont supposés homogènes.

## Analyse par type de climat

Compte tenu de l'importance des variables climatiques dans le contrôle de la distribution spatiale des teneurs en carbone organique, une stratification des analyses précédemment réalisées est proposée. Celle-ci est basée sur une typologie des types de climat [Joly et al., 2010](http://cybergeo.revues.org/23155). La typologie est consultable sur cette [page](https://github.com/GisEDSol/Carbo_elevage/blob/master/Documentation/Metadonnees/Nomenclature_typeclimat.csv).

*La construction des données climatiques est consultable sur ce fichier [FS_bdd_elab_climat.Rmd](https://github.com/GisEDSol/Carbo_elevage/blob/master/Fichiers_suivis/BDD/Suivis/FS_bdd_elab_climat.Rmd)*

Le tableau ci-dessus présente le nombre de canton pourvu en analyse de la BDAT par type de climat. Les types de climats **6, 7 et 8** englobent moins de 100 cantons. Ils seront écartés de l'analyse pour des raisons 
Parmi les strates restantes, la variabilité dans le nombre d'analyse est importante, passant de 163 pour le type 1 à 722 pour le type 3. Ces différences seront à prendre en compte dans l'analyse des résultats.

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
#melted.bdat$typo_climsple <- melted.bdat$typo_clim
#melted.bdat$typo_climsple[melted.bdat$typo_climsple %in% c("4","5")] <- "45"
p <- list()
for(i in levels(as.factor(melted.bdat$typo_clim))){
  melted.test <- melted.bdat[melted.bdat$typo_clim %in% i & melted.bdat$variable %in% "med_corgox",]
  p[[i]] <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
}
clim_nbranalyses <- as.data.frame(melt(p))
colnames(clim_nbranalyses) <- c("Nbr","Type_climat")
pander(clim_nbranalyses[,c("Type_climat","Nbr")],caption="Nombre d'analyse par type de climat")

#Voir pour power.t.test
```

### Cartographie des types de climat

La carte ci-dessous présente la typologie proposée. Pour une description des types de climat, voir [Joly et al., 2010](http://cybergeo.revues.org/23155).

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
tablecarto <- "dm_vecteurs.canton" 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" 
variablecarto <- "typo_clim" #variable à spatialiser
l_legend <- "Type de climat"#label de la variable
nclasse <- 8 #Nombre de classes de valeurs pour la cartographie
style_classe <- "fixed" #"pretty"#"jenks","fixed"
nomfichier <- "typo_clim"

code_typoclim <- read.csv(paste(repmetadonnees,"Nomenclature_typeclimat.csv",sep=""))
couleur <- as.character(code_typoclim$Code_couleur)

carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_legend,repsortie,nomfichier,title="",caption="",dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=3,position="bottom",ggsaveheight=7,ggsavewidth=10)
```

```{r, echo = F, results = 'asis'}
# Pour insérer l'image
fichiers <- paste(repsortie,"typo_clim.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Statistiques descriptives

On commence par analyser les teneurs par strates géographiques...
Ci-dessous, la figure présente la répartition des teneurs en C pour les différentes périodes et pour les principales régions d'élevage. Rajouter les différences significatives


```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("boxplot_regclim",""),fig.align="center"}
code_typoclim <- read.csv(paste(repmetadonnees,"Nomenclature_typeclimat.csv",sep=""))
typo_clim <- 1:5
couleur <- as.character(code_typoclim[code_typoclim$Code %in% typo_clim,"Code_couleur"])

melted.bdat_clim <- melted.bdat[(melted.bdat$variable %in% "med_corgox") & (melted.bdat$typo_clim %in% typo_clim),]
labtest <- generate_label_df(db=melted.bdat_clim,value="value",lev="typo_clim",letters,position=1)

p <- ggplot(melted.bdat_clim) + geom_boxplot(aes(x=typo_clim,y=value,fill=typo_clim))+scale_x_discrete("Type de climat")+scale_y_continuous("Teneur en carbone organique (g/kg)")+scale_fill_manual(values=couleur,name="")+theme_perso(position="") +geom_text(data = labtest,vjust=-1,aes(x = plot.labels, y = V1, label = labels))
            
p  
#ggsave(p,file = paste(repsortie,"boxplotbdat_zonage_cplt.png",sep=""), width = 12, height = 6)  
```

```{r cdf_clim,highlight=TRUE,echo=FALSE,eval=TRUE,fig.height=10, fig.width=10,fig.cap = fig$cap("cdf_clim",""),fig.align="center"}
cdf_clim <- ggplot(melted.bdat_clim, aes(x=value))+
       facet_wrap(~typo_clim)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=couleur, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_clim
#ggsave(cdf_clim,file = paste(repsortie,"cdf_clim.png",sep=""), width = 12, height = 10)  
```
La figure `r fig$ref("cdf_clim",link=TRUE)` présente les courbes de fréquence cumulées pour les différents types de climats. Les courbes de fréquences cumulées pour les 5 types de climats sélectionnés présentent une forme similaire. Les courbes des différentes périodes tendent vers des valeurs de teneurs en CO plus faible sur une large gamme de teneur pour les types de climat 1, 2, 3 et 4. Dans ces 2 cas, les périodes 0004 et 0509 présentent des valeurs plus faibles que les teneurs 9599 et 1014. Dans le type de climat 4, l'évolution des teneurs s'accentue sur la gamme 17-30 g/kg. Sur cette gamme, la période 1014 est particulièrement contributrice de la baisse des teneurs. A l'inverse, la période 0509 montrent des teneurs en CO plus forte pour cette gamme de valeur. Dans la zone climatique 2, les périodes 0004 et 0509 présentent des teneurs en CO plus faible que les teneurs initiales et celles de la période 2010-2014. Ces évolutions impliquent l'ensemble de la gamme des teneurs en CO.

La courbe de fréquence cumulée pour le type de climat 5 présente une dynamique similaire avec des changements important pour les teneurs en CO de 20-30 g/kg. Dans cette situation, la période 1014 présente également une courbe avec des teneurs en CO plus faible que la période 9599 et des teneurs en CO plus forte pour 0509 et 0004.

**Cette figure montre des tendances comparables entre les types de climats. L'évolution des teneurs en CO est différente en fonction des gammes des teneurs en CO : la période 1014 présente une forte diminution sur les teneurs 17-30 g/kg et une augmentation sur les teneurs inférieures. Les périodes 0004 et 0509 affichent une tendance inverse.**

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=7,fig.cap = fig$cap("boxplot_clim",""),fig.align="center",warning=FALSE,message=FALSE}

ylim1 <- c(min(melted.bdat$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))
colors <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

boxplot_clim <- ggplot(melted.bdat[melted.bdat$typo_clim %in% 1:5,],aes(x=annees,y=value,fill=variable)) +
            geom_boxplot(outlier.shape = NA,outlier.size=NA)+
            stat_summary(fun.y=median, geom="line",size = 1, aes(group=variable,color=variable))+
            facet_wrap(~typo_clim,scales="free")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)

boxplot_clim

#ggsave(boxplot_clim,file = paste(repsortie,"boxplot_clim2.jpg",sep=""), width = 7, height = 6)  
```

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE,results="asis"}
panderOptions('knitr.auto.asis', FALSE)
p <- list()
for(i in levels(as.factor(melted.bdat_clim$typo_clim))){
  melted.test <- melted.bdat_clim[melted.bdat_clim$typo_clim %in% i,]   
  bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
  nbrobservation <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
  bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
  pander(bdatsummary[[1]],caption = paste("Statistiques descriptives des teneurs en carbone organique pour le type de climat ",i,". Nombre de canton analysé : ",nbrobservation,sep=""))
}
```

## Intensité des évolutions par type de climat

```{r echo=FALSE,eval=TRUE,results='asis'}
for(i in levels(as.factor(melted.bdat$variable))){
  cpt <- 0
  for(s in 1:5){
    cpt <- cpt + 1
    melted.test <- melted.bdat[(melted.bdat$variable %in% i) & melted.bdat$typo_clim %in% s,]
    bdatmedian <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],median))

    colnames(bdatmedian) <- "median"
    bdatmedian <- t(bdatmedian)
    colnames(bdatmedian) <- c("1995-1999","2000-2004","2005-2009","2010-2014")

    res <- outer(1:ncol(bdatmedian), 1:ncol(bdatmedian), 
                function(x,y) ((bdatmedian[,x]-bdatmedian[,y])/bdatmedian[,x])*100)
    period_count <- c(1995,2000,2005,2010)

    res_period <- outer(1:length(period_count), 1:length(period_count), 
                function(x,y) ((period_count[x])-period_count[y]))

    res[upper.tri(res, diag = TRUE)] <- NA
    res2 <- res/res_period
    colnames(res2) <- as.character(colnames(bdatmedian))
    rownames(res2) <- as.character(colnames(bdatmedian))
 
    bdatmedian2 <- melt(res2)
    bdatmedian2 <- bdatmedian2[complete.cases(bdatmedian2$value),]
    bdatmedian2$count <- c("23","24","25","34","35","45")
    colnames(bdatmedian2) <- c("EndDate","StartDate",paste("txevol_",s,sep=""),"Count")

    if(cpt==1){
     # Construction de la première table
     stats.canton <- bdatmedian2
      }else{
       # Ajout à chaque itération de la variable (i)
       stats.canton <- merge(stats.canton,bdatmedian2, by.x=c("EndDate","StartDate","Count"), by.y=c("EndDate","StartDate","Count"),all.x=FALSE,all.y=FALSE)      
     }   
  }
meltstats <- melt(stats.canton,id.vars=c("EndDate","StartDate","Count"))
  p[[i]] <- ggplot(meltstats, aes(ymin = StartDate, ymax = EndDate, x = Count)) + geom_linerange(aes(colour=value),size=3) + facet_wrap(~variable) + coord_flip() + scale_colour_gradient2(limit = c(min(meltstats$value),max(meltstats$value)),high=muted("green"),name="Taux d'évolution annuel (%)") + ylab("Périodes") + xlab("") + theme_perso() + geom_text(aes(y = StartDate, x = Count, label = paste(round(value,1),"%",sep="")), hjust = 0, vjust = -1, size = 5) + labs(title= paste(i))
}   
tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))
tt

```
La figure `r fig$ref("boxplot_clim",link=TRUE)` représente la distribution des teneurs en carbone organique sous forme de boxplot pour les différentes périodes et les différentes zones climatiques. Les tableaux ci-dessus présentent les statistiques descriptives des teneurs en CO pour les différentes périodes et les différents types de climat. De ces tableaux et de ces boxplots, les zones 1, 2, 3 et 4 présentent une dynamique similaire avec une baisse puis une augmentation des teneurs. Ces évolutions se rapprochent des tendances nationales précédemment observées. Entre ces zones, seul les résultats pour le type de climat 3 sont significatifs. **La baisse des teneurs entre 9599 et 0004 et l'augmentation des teneurs en CO entre 0004 et 1014 et 0509-1014 sont significatives.** 

La zone 5 présente une évolution en dent de scie, avec une augmentation, une diminution et une augmentation. Ces évolutions ne sont pas significatives d'après le test de Wilcoxon.

```{r,eval=TRUE,echo=FALSE,warning=FALSE,error=FALSE,message=FALSE}
p <- list()
for(s in levels(as.factor(melted.bdat$variable))){
  for(i in levels(as.factor(melted.bdat_clim$typo_clim))){
  melted.test <- melted.bdat[(melted.bdat$variable %in% s) & (melted.bdat$typo_clim %in% i),]
  p[[paste(s,"_",i,sep="")]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
  if(p[[paste(s,"_",i,sep="")]]$p.value <= 0.05){
  print(p[[paste(s,"_",i,sep="")]])}else{}
  }
}
```

## Analyse par région d'élevage

Les grandes régions d'élevage représentent un zonage des principaux systèmes d'élevage en France. Le zonage a été construit sur la base de critères pédo-climatiques et d'un regroupement des petites régions agricoles. Par construction, ce zonage propose donc un regroupement de zones où les conditions d'apport, de stockage et d'évolution de carbone dans le sol peuvent être homogène.

**Il représente donc un zonage intéressant à exploiter pour étudier les évolutions des teneurs en CO à l'échelle de la France sous le regard de compartiments fonctionnels homogènes.**

```{r ,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',warning=FALSE,message=FALSE}
p <- list()
for(i in levels(as.factor(melted.bdat$zonage_cplt))){
  melted.test <- melted.bdat[melted.bdat$zonage_cplt %in% i & melted.bdat$variable %in% "med_corgox",]
  p[[i]] <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
}
regelevage_nbranalyses <- as.data.frame(melt(p))
colnames(regelevage_nbranalyses) <- c("Nbr","Region_elevage")

pander(regelevage_nbranalyses[,c("Region_elevage","Nbr")],caption="Nombre de canton possédant des analyses par type de région d'élevage")
```

Le tableau ci-dessus présente le nombre de canton ayant des analyses en teneurs en CO par type de région d'élevage. Les régions d'élevages où le nombre de canton est inférieur à 100 sont éliminées. Il reste donc les régions suivants :

- A : Zones de grandes cultures ou sans élevage
- B1 : Zone de polyculture-élevage du Bassin Aquitain & Rhône-Alpes & Alsace
- B2 : Zone de polyculture-élevage du Bassin Parisien
- C1 : Zone intensive du Grand Ouest (zone laitière avec alternatives à l’élevage)
- D : Zone herbagère du Nord-Ouest
- E1 : Zone herbagère du Nord-Est (de tradition laitière)
- E2 : Zone herbagère du Nord Massif-Central (de tradition allaitante)

Parmi les strates restantes, la variabilité dans le nombre d'analyse est importante, passant de 163 pour le type 1 à 722 pour le type 3. 

### Cartographie

```{r,highlight=TRUE,eval=FALSE,echo=FALSE}
tablecarto <- "dm_vecteurs.canton" 
dsn <- "PG:dbname='sol_elevage' host='localhost' port='5432' user='jb'" 
variablecarto <- "zonage_cplt" #variable à spatialiser
l_legend <- "Principales régions d'élevage"#label de la variable
nclasse <- 13 #Nombre de classes de valeurs pour la cartographie
style_classe <- "fixed" #"pretty"#"jenks","fixed"
nomfichier <- "reg_elevage_cplt"
code_regelevage <- read.csv(paste(repmetadonnees,"Nomenclature_regionelevage.csv",sep=""))

couleur <- as.character(code_regelevage$Code_couleur)
carto(dsn,tablecarto,variablecarto,nclasse,style_classe,couleur,l_legend=l_legend,repsortie,nomfichier,title="",caption="",dept=FALSE,reg=FALSE,nrowlayout=2,ncollayout=3,position="bottom",ggsaveheight=7,ggsavewidth=10)
```

```{r, echo = F, results = 'asis',warning=FALSE,error=FALSE,message=FALSE}
# Pour insérer l'image
fichiers <- paste(repsortie,"reg_elevage_cplt.png",sep="")
cat(paste("![](",fichiers,")",sep=""))
```

### Statistiques descriptives

On commence par analyser les teneurs par strates géographiques...
Ci-dessous, la figure présente la répartition des teneurs en C pour les différentes périodes et pour les principales régions d'élevage. Rajouter les différences significatives

```{r boxplot_reg_elevagezoom,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=12,fig.cap = fig$cap("boxplot_regelevage",""),fig.align="center"}
# Lecture de la table des couleurs
code_regelevage <- read.csv(paste(repmetadonnees,"Nomenclature_regionelevage.csv",sep=""))

period <- c("9599","0004","0509","1014")
reg_elevage <- c("A","B1","B2","C1","D","E1","E2")
couleur <- as.character(code_regelevage[code_regelevage$Zonage_cplt %in% reg_elevage,"Code_couleur"])

melted.bdat_regelevage <- melted.bdat[complete.cases(melted.bdat$zonage_cplt) & (melted.bdat$zonage_cplt %in% reg_elevage) & melted.bdat$variable %in% "med_corgox",]

wilcotest <- generate_label_df(db=melted.bdat_regelevage,value="value",lev="zonage_cplt",letters,position=1)

pairwise.wilcox.test(melted.bdat_regelevage[,"value"], melted.bdat_regelevage[,"zonage_cplt"])

p <- ggplot(melted.bdat_regelevage) +
            geom_boxplot(aes(x=zonage_cplt,y=value,fill=zonage_cplt))+
            scale_fill_manual(values=couleur[1:7],name="") + scale_x_discrete("Grandes régions d'élevage")+scale_y_continuous("Teneur en carbone organique (g/kg)")+ theme_perso("") + geom_text(data = wilcotest, vjust=-0.75,aes(x = plot.labels, y = V1, label = labels))
            
p 
#ggsave(p,file = paste(repsortie,"boxplotbdat_zonage_cplt.png",sep=""), width = 12, height = 6)  
```

```{r, eval=TRUE,echo=FALSE}
#pairwise.wilcox.test(melted.bdat_regelevage[,"value"], melted.bdat_regelevage[,"zonage_cplt"])
p <- list()
for(s in levels(as.factor(melted.bdat$variable))){
  for(i in levels(as.factor(melted.bdat_regelevage$zonage_cplt))){
  melted.test <- melted.bdat[(melted.bdat$variable %in% s) & (melted.bdat$zonage_cplt %in% i),]
  p[[paste(s,"_",i,sep="")]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
   if(p[[paste(s,"_",i,sep="")]]$p.value <= 0.05){
  print(p[[paste(s,"_",i,sep="")]])}else{}
  }
}
print(p)
```

```{r,highlight=TRUE,eval=FALSE,message=FALSE,echo=FALSE}
# Ici, voir pour rajouter année+zonage_simple ou année+climato ou année+région
bdatsummary_regelevage <- apply(melted.bdat["value"],2, function(x) tapply(x, list(melted.bdat[,"zonage_simple"],melted.bdat[,"annees"]),summary))
bdatsummary_regelevage <- data.frame(bdatsummary_regelevage[[1]])
bdatsummary_regelevage <- lapply(bdatsummary_regelevage, do.call, what = rbind)
names(bdatsummary_regelevage) <- period
```

La figure `r fig$ref("cdf_regelevage",link=TRUE)` présente les courbes de fréquences cumulées pour les différentes régions d'élevage. Sur cette figure, on remarque l'effet les différences de la densité d'analyse par région. Les régions C2, G1 et G2 présentent des courbes en marche d'escalier, illustrant un nombre insuffisant de données.
Mise à part ces différences, la forme des courbes est globalement similaire pour les différentes strates des régions d'élevage. En revanche, les tendances d'évolution des teneurs en CO sont différentes. Par exemple, dans la région C2, la fréquences des teneurs fortes en CO augmente pour les périodes 0004-0509 tandis que ces mêmes périodes affichent des diminutions importantes sur les zones D et E1 notamment.

A ce niveau, il est difficile de rentrer dans le détail. D'autres figures sont produites ci-dessous pour améliorer l'analyse de l'évolution des teneurs au niveau des différentes régions d'élevage.

```{r cdf_regelevage,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=10, fig.width=12,fig.cap = fig$cap("cdf_regelevage",""),fig.align="center"}
cdf_regelevage <- ggplot(melted.bdat_regelevage, aes(x=value))+
       facet_wrap(~zonage_cplt)+
       stat_ecdf(aes(colour=annees))+
       scale_color_manual(values=couleur, 
                          name="Périodes")+
       scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
       theme(plot.title = element_text(size = 14, face = "bold"), 
             text = element_text(size = 12),
             axis.title = element_text(face="bold"),
             axis.text.x=element_text(size = 11))
cdf_regelevage
#ggsave(cdf_regelevage,file = paste(repsortie,"cdf_regelevage.png",sep=""), width = 12, height = 10) 
```
Avant tout, les tables ci-dessous présentent les résultats des tests de Wilcoxon. Mis à part les zones d'élevage A et dans une moindre mesure B1, l'ensemble des régions d'élevage ne présente pas de différences significatives. **Attention, il s'agit d'analyse à l'échelle de la région d'élevage et non du canton**.

Ces résultats atténuent les observations visibles sur les figures ci-dessous (voir figure `r fig$ref("boxplot_regelevage2",link=TRUE)`). Celles-ci présentent des évolutions frappantes et différentes selon les régions, **mais elles ne sont pas significatives.**

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE}
p <- list()
for(i in levels(as.factor(melted.bdat_regelevage$zonage_cplt))){
  melted.test <- melted.bdat_regelevage[melted.bdat_regelevage$zonage_cplt %in% i,]
  p[[i]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])

bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
#ggplot(melted.test) + geom_boxplot(aes(x=annees,y=value),notch=TRUE)
}
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=12,fig.cap = fig$cap("boxplot_regelevage2",""),fig.align="center",warning=FALSE,message=FALSE}
ylim1 <- c(min(melted.bdat$value,na.rm=TRUE),quantile(melted.bdat$value,0.99,na.rm=TRUE))

boxplot_reg_elevage <- ggplot(melted.bdat[melted.bdat$zonage_cplt %in% reg_elevage,],aes(x=annees,y=value,fill=variable)) +
            geom_boxplot(outlier.shape = NA,outlier.size=NA)+
            stat_summary(fun.y=median, geom="line",size = 1, aes(group=variable,color=variable))+
            facet_wrap(~zonage_cplt,scales="free")+
            scale_x_discrete("Périodes")+scale_y_continuous("Teneur en carbone (g/kg)")+
            theme(plot.title = element_text(size = 14, face = "bold"), 
                  text = element_text(size = 12),
                  axis.title = element_text(face="bold"),
                  axis.text.x=element_text(size = 11))+
            coord_cartesian(ylim = ylim1*1.05)

boxplot_reg_elevage

# Voir pour apporter les résultats des tests avec l'ajout de cette fonctionnalité (http://stackoverflow.com/questions/12603988/what-is-the-ggplot2-plyr-way-to-calculate-statistical-tests-between-two-subgroup)
#ddply(diam,"color",
 #     function(x) {
  #        w <- wilcox.test(price~cut,data=x)
   #       with(w,data.frame(statistic,p.value))
    #  })
#ggsave(boxplot_clim,file = paste(repsortie,"boxplot_clim2.jpg",sep=""), width = 7, height = 6)  

panderOptions('knitr.auto.asis', FALSE)
p <- list()
for(i in levels(as.factor(melted.bdat_regelevage$zonage_cplt))){
  melted.test <- melted.bdat_regelevage[melted.bdat_regelevage$zonage_cplt%in% i,]   
  bdatsummary <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],summary))
  nbrobservation <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],length))[1,1]
  bdatsummary <- lapply(bdatsummary, do.call, what = rbind)
  pander(bdatsummary[[1]],caption = paste("Statistiques descriptives des teneurs en carbone organique pour le type de climat ",i,". Nombre de canton analysé : ",nbrobservation,sep=""))
}
```
```{r echo=FALSE,eval=TRUE,results='asis'}
for(i in levels(as.factor(melted.bdat$variable))){
  cpt <- 0
  for(s in levels(as.factor(melted.bdat$zonage_cplt))){
    cpt <- cpt + 1
    melted.test <- melted.bdat[(melted.bdat$variable %in% i) & melted.bdat$zonage_cplt %in% s,]
    
    # Utiliser les sorties de pairwise.wilcox.test pour rajouter un indicateur de différence significative sur les graphiques de taux d'évolution (genre %)
    res.wilcoxon <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])$p.value
    res.wilcoxon[upper.tri(res.wilcoxon, diag = FALSE)] <- NA


    bdatmedian <- apply(melted.test["value"],2, function(x) tapply(x, melted.test[,"annees"],median))

    colnames(bdatmedian) <- "median"
    bdatmedian <- t(bdatmedian)
    colnames(bdatmedian) <- c("1995-1999","2000-2004","2005-2009","2010-2014")

    res <- outer(1:ncol(bdatmedian), 1:ncol(bdatmedian), 
                function(x,y) ((bdatmedian[,x]-bdatmedian[,y])/bdatmedian[,x])*100)
    period_count <- c(1995,2000,2005,2010)

    res_period <- outer(1:length(period_count), 1:length(period_count), 
                function(x,y) ((period_count[x])-period_count[y]))

    res[upper.tri(res, diag = TRUE)] <- NA
    res2 <- res/res_period
    colnames(res2) <- as.character(colnames(bdatmedian))
    rownames(res2) <- as.character(colnames(bdatmedian))
 
    bdatmedian2 <- melt(res2)
    bdatmedian2 <- bdatmedian2[complete.cases(bdatmedian2$value),]
    bdatmedian2$count <- c("23","24","25","34","35","45")
    colnames(bdatmedian2) <- c("EndDate","StartDate",paste("txevol_",s,sep=""),"Count")

    if(cpt==1){
     # Construction de la première table
     stats.canton <- bdatmedian2
      }else{
       # Ajout à chaque itération de la variable (i)
       stats.canton <- merge(stats.canton,bdatmedian2, by.x=c("EndDate","StartDate","Count"), by.y=c("EndDate","StartDate","Count"),all.x=FALSE,all.y=FALSE)      
     }   
  }
  meltstats <- melt(stats.canton,id.vars=c("EndDate","StartDate","Count"))

  p[[i]] <- ggplot(meltstats, aes(ymin = StartDate, ymax = EndDate, x = Count)) + geom_linerange(aes(colour=value),size=3) + facet_wrap(~variable) + coord_flip() + scale_colour_gradient2(limit = c(min(meltstats$value),max(meltstats$value)),high=muted("green"),name="Taux d'évolution annuel (%)") + ylab("Périodes") + xlab("") + theme_perso() + geom_text(aes(y = StartDate, x = Count, label = paste(round(value,1),"%",sep="")), hjust = 0, vjust = 0.5, size = 3.5) + labs(title= paste(i))
}   
tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=1,ncol=2,position="bottom")))
tt


## En cours##
p <- list()
for(s in levels(as.factor(melted.bdat$variable))){
  for(i in levels(as.factor(melted.bdat_regelevage$zonage_cplt))){
  melted.test <- melted.bdat[(melted.bdat$variable %in% s) & (melted.bdat$zonage_cplt %in% i),]
  p[[paste(s,"_",i,sep="")]] <- pairwise.wilcox.test(melted.test[,"value"], melted.test[,"annees"])
   if(p[[paste(s,"_",i,sep="")]]$p.value <= 0.05){
  print(p[[paste(s,"_",i,sep="")]])}else{}
  }
}
print(p)
```

## Analyse par occupation du sol (Test)


```{r eval=TRUE,echo=FALSE}
period <- c("9599","0004","0509","1014")
xlabel <- "Carbone organique (g/kg)"

melted.bdat_prairie <- melted.bdat[complete.cases(melted.bdat$classe_p_prairie1988),]

test1 <- generate_label_df(db=melted.bdat_prairie[melted.bdat_prairie$variable %in% "med_corgox",],value="value",lev="classe_p_prairie1988",LETTERS,position=1)
test2 <- generate_label_df(db=melted.bdat_prairie[melted.bdat_prairie$variable %in% "75% centile",],value="value",lev="classe_p_prairie1988",letters,position=1)
 
p <- ggplot(melted.bdat_prairie) +
            geom_boxplot(aes(x=classe_p_prairie1988,y=value,color=variable))+
            #geom_smooth(aes(x=as.integer(annees),y=value,color=zonage_simple,fill=zonage_simple),method=loess)+
            #scale_color_manual(values=colors,name="Années")
            scale_x_discrete("Pourcentage de prairies dans la SAU")+scale_y_continuous("Teneur en CO (g/kg)")+
  geom_text(data = test1, hjust = 2.4,vjust=-0.75,aes(x = plot.labels, y = V1, label = labels))+
  geom_text(data = test2,hjust = -2.4,vjust=-0.75, aes(x = plot.labels, y = V1, label = labels))+theme_perso()
p
```

## Conclusion 

L'étude des teneurs en CO au niveau des différentes strates géographiques de type climatique et d'élevage a revélé des difficultés d'analyse en raison d'un nombre limité de données par strates. Les tendances observées à l'échelle des strates ne sont pas significatives et le faible nombre d'analyse dans les strates peut expliquer ces résultats.

Toutefois, sur l'ensemble des périodes analysées, les différences des teneurs entre les différentes strates géographiques sont systématiquement différentes. Ce qui démonter l'intérêt de travailler sur ce niveau d'échelle.? 

# Analyse des facteurs contrôlant la distribution spatiale

Dans cette partie, les facteurs contrôlant la distribution spatiale des teneurs en carbone organique des différentes périodes sont analysés. Le travail est dans un premier temps porté par une analyse en composante principale pour identifier les relations entre les facteurs potentiellement explicatifs et identifier les principales variables d'intérêts. Dans un deuxième temps par une modélisation avec la méthode des arbres de régression boostés pour affiner l'analyser et classer les variables explicatives par ordre d'importance (contribution).

## Analyse en composante principale 

```{r,highlight=TRUE,eval=TRUE,echo=FALSE}
# Sélection des variables de travail
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
typeoccup <- replicate(length(Ranthrop), "occup")

type <- c(typeclimato,typetopo,typeoccup)
Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop,"classe_C")
vNames <- c("corgox9599",Rcovar)

# Lecture de la table sans les NA
lvNames <- length(vNames)
dcast.bdat_variables <- dcast.bdat[complete.cases(dcast.bdat[,vNames[-lvNames]]),vNames[-lvNames]]

# Création d'une classe de valeur pour le carbone
classe_valeur <- classIntervals(dcast.bdat_variables[vNames[1]][[1]],n=4,style="quantile",digits=1,na.rm=TRUE)[[2]]
dcast.bdat_variables[,"classe_C"] <- cut(dcast.bdat_variables[vNames[1]][[1]],breaks = data.frame(classe_valeur)[,1],include.lowest=T) 

res.pca <- PCA(dcast.bdat_variables[,!names(dcast.bdat_variables) %in% "classe_C"], quanti.sup=1,graph = FALSE)

#
pca <- fviz_pca_var(res.pca, axes = c(1,2),col.var="contrib") +
scale_color_gradient2(low="white", mid="blue", 
                  high="red", midpoint=50) + theme_minimal()
```

La figure `r fig$ref("pca_fr",link=TRUE)` présente la distribution des variables sur les axes 1 et 2 de l'ACP. Environ `r round(res.pca$eig[1,2]+res.pca$eig[2,2])` pourcent de l'information est contenu dans ces deux premiers axes. Description de la distribution des variables dans l'espace des ACP : 

- L'axe 1 représente `r round(res.pca$eig[1,2])`% de l'information. Cet axe est fortement associé à l'occupation du sol. Les différentes variables associées aux grandes cultures et à l'élevage sont bien représentées et ont une forte contribution dans la variance du jeu de données. Les statistiques liées à la part d'STH, de prairies, de SFP et d'OTEX polyculture élevage sont corrélées et sont opposées aux variables associées aux grandes cultures (proportion des surfaces de céréales/SAU et OTEX grandes cultures). 
- L'axe 2 représente `r round(res.pca$eig[2,2])`% de l'information. La correlation avec les variables est moins nette que l'axe 1. Les variables de type climat et topographie sont légèrement correlées à cet axe. D'autres variables d'occupation du sol sont associées à l'axe 2. Celles-ci concernent les zones agricoles hétérogènes ($clc_25_90$), les zones de maïs fourrage et les zones qui ont une densité importante en UGBTA. Logiquement, ces deux dernière variables sont liées.

* Les variables liées à Corine Land Cover ont un faible impact dans l'espace de corrélation. Etant donné qu'elle représente une information similaire aux données du recencement agricole, elle sont éliminées du jeu d'analyse par la suite.*

Dans cet espace, la teneur en carbone organique initiale (période 90-94) est moyennement représentée (-50% de contribution). Cette variable est directement opposée aux variables climatiques ce qui met en valeur l'importance de ce facteur dans la distribution spatiale des teneurs à l'échelle de la France.
Dans une moindre mesure, la teneur en CO est correlée aux surfaces fourragères principales et aux UGBTA.

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=8, fig.width=8,fig.cap = fig$cap("pca_fr",""),fig.align="center"}
pca
# revoir cette discussion sur l'intérêt de la PCA pour la sélection des variables. A titre de conclusion, c'est assez intéressant.http://stats.stackexchange.com/questions/27300/using-principal-component-analysis-pca-for-feature-selection
```
## Test d'endogénéité des variables d'occupation du sol

L'objectif de cette partie est d'évaluer l'endogénéité des différentes variables d'occupation du sol. La notion d'endogénéité provient de l'économétrie et résulte de la corrélation entre un paramètre étudié et son résidu. Dans notre situation, l'hypothèse d'endogénéité est suspectée sur les variables d'occupation du sol car celle-ci influencent les teneurs en carbonique mais peuvent également dépendre de la teneur en CO du sol.

Le code ci-dessous présente l'application du test de Wu-Hausman. L'application de ce test demande l'utilisation d'instrument pour tester l'endogénéité. Les teneurs en CO pour des périodes postérieures aux périodes de l'occupation du sol ont été utilisées. 

Le tableau ci-dessous présente les résultats du test appliqué pour toutes les variables d'occupation du sol. Le test de Sargan permet de tester la validité des instruments utilisés et les p_value du test d'Hausman permettent d'identifier les variables endogènes.

Les p-value sont supérieures à 0.05 et l'hypothèse null ne peut être rejeté. L'ensemble des variables testées ne sont pas endogènes. Les intruments utilisés sont tous valides à l'exception du test appliquée sur l'OTEX grandes cultures en 1988.

```{r,highlight=TRUE,eval=TRUE,echo=TRUE,results = 'asis',warning=FALSE}
# selon http://eclr.humanities.manchester.ac.uk/index.php/IV_in_R
library(AER,lmtest)

# Variables d'occupation du sol suspectées d'être endogène
endo <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")

# Ensemble des variables exogènes (climat+topo+pédo)
exo <- c("altimean","hpluie_an","jchauds_an","jfroids_an","pluie_ecart_janv","std_pluie_juil","std_temp_janv","std_temp_juil","argi_med","sabt_med")
exoplus <- paste(exo,collapse="+")
variamodel <- c(endo,exo)

# Instrument (teneur en carbone sur deux périodes postérieur aux occupations du sol(>2000))
instru <- c("corgox1014","corgox0509")
instruplus <- paste(instru,collapse="+")

vNames <- unique(c("corgox9599",instru,variamodel))
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]

# Test des instruments et de l'endogénéité
intrutest <- list()
HausWu <- list()
for(i in endo){
  varia <- variamodel[!variamodel %in% i]
  
  # Régression linéaire entre la variable endogène et les instrus et les variables exogènes
  first_stage <- lm(paste(i, " ~ ", paste(c(exoplus,instruplus),collapse="+"),sep=""),data=d)
  
  instrHausWutest <- waldtest(first_stage,.~.-corgox1014-corgox0509)
  intrutest[[i]] <- instrHausWutest[2,4]#Sargan

  # Régression linéaire du carbone (1995-1999) avec les variables exogènes et le résidu de la première régression linéaire
  Hausman_reg <- lm(paste(vNames[1], " ~ ", paste(exo,collapse="+"),"+first_stage$residuals",sep=""),data=d)#Ajout des résidus au modèle de base
  
  # Comparaison des deux modèles 
  HausWutest <- waldtest(Hausman_reg,.~.-first_stage$residuals)
  HausWu[[i]] <- HausWutest[2,4]
}

rest <- cbind.data.frame(melt(intrutest),melt(HausWu))[,1:3]
colnames(rest) <- c("Sargan_test","Variables","Hausman_test")
pander(rest,caption="Résutlats des tests d'endogénéité (test de Wu-Hausman)")
```

## Sélection des variables d'intérêt

L'objectif de cette partie est de sélectionner les principales variables explicatives et d'étudier l'effet des variables d'origines anthropiques sur un modèle linéaire des teneurs en CO. Pour cela, l'algorithmme suivant est appliqué :

- 1 : Pour chaque type de variables explicatives (naturelle et anthropique), application d'un modèle linéaire avec sélection du meilleur modèle sur deux critères :
  * VIF : Sélection selon un critère de multicollinéarité (variance inflation factor, VIF.
  * L'AIC : Les variables sélectionnées précédemment sont utilisé pour construire un modèle linéaire dans lequel les variables sont sélectionnées selon l'AIC. La méthode utilisée pour construire les modèles est basé sur le stepwise/backward (fonction stepAIC).
- 2 : Identification des meilleurs modèles et calcul du R2 non-ajusté
- 3 : Construction d'un modèle linéaire basé sur les variables anthropiques et naturelles précédemment sélectionnés. Calcul du R2 non-ajusté et comparaison avec les modèles linéaires anthropiques et naturelles.

```{r,eval=FALSE,echo=FALSE,message=FALSE,warning=FALSE}
#library(relaimpo)
#library(earth)

# Sélection des variables de travail
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato,Rcovarpedo)

periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")

Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")

# Lancement de la fonction pour calculer le R2 des différentes types de variables

#d=d2
#Rnaturel
#Ranthrop
#Variay<-i

p <- list()
lmcpl <- list()
formule <- list()
indexperiod <- list(1:3,1:4,1:4,1:5)
cpt <- 0

for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})
  Rcovaroccup <- c(ra_otex,ra_occupyears)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)
  vNames <- c(i,Rcovar)

  d2 <- dcast.bdat[complete.cases(dcast.bdat[,vNames]),vNames]
  plm <- lm_variatype(d2,Rnaturel,Ranthrop,i)
  
  p[[i]] <- plm$df[1:3]
  lmcpl[[i]] <- plm$lmcplt
  formule[[i]] <- plm$df[1:4]
}

save(p,file=paste(repsortie,"p_lm_variatype.RData",sep=""))

```
Les résultats de ces tests sont présentés dans le tableau ci-dessous. Pour l'ensemble des teneurs en CO modélisé, la part des variables de types anthropiques est toujours la plus faible. Elle se situe entre 5 et 7% pour les (voir deuxième tableaux ci-dessous). La part des variables naturelle (topographie, pédologie et climat) est bien plus importante. 

```{r summaryR2ml_fr,highlight=TRUE,echo=FALSE,eval=TRUE,results = 'asis',message=FALSE,warning=FALSE}
load(paste(repsortie,"p_lm_variatype.RData",sep=""))
#p2 <- melt(p)
#colnames(p2) <- c("Type_variable","Indicateur","R2_nonajusté","Teneur_CO")
#pander(p2[,c("Teneur_CO","Type_variable","R2_nonajusté")])
p2 <- do.call("rbind",p)
rownames(p2) <- NULL
p2$Teneur_CO <- c(replicate(3,"corgox9599"),replicate(3,"corgox0004"),replicate(3,"corgox0509"),replicate(3,"corgox1014"))
colnames(p2) <- c("Type_variable","R2_nonajusté","durbinWatsonTest","Teneur_CO")
pander(p2[,c("Teneur_CO","Type_variable","R2_nonajusté","durbinWatsonTest")])

p3 <- list()
for(i in as.factor(unique(p2["Teneur_CO"])[[1]])){
  p3[[i]] <- round((p2[p2$Teneur_CO %in% i,][3,"R2_nonajusté"]-p2[p2$Teneur_CO %in% i,][2,"R2_nonajusté"])*100,2)
}
p3 <- as.data.frame(p3)
pander(p3,caption="Contribution (en %) des variables anthropiques dans la modélisation des teneurs en carbone organique pour les différentes périodes")
```

## Modèle de fouille de données

Dans cette partie, on testera rapidement deux modèles de fouille de données utilisés dans plusieurs travaux sur les sols (voir [Murciano et al., 2015](http://www.afes.fr/afes/egs/EGS_22_1_2201_09_18murciano_final.pdf) pour une description des modèles)

- GBM : Le principe de cet algorithme est de construire une séquence de modèles afin qu’à chaque
étape, chaque modèle ajouté à la combinaison apparaisse comme un pas vers une meilleure solution.
- Cubist : Cubist est un modèle de régression axé prédiction qui combine les idées de modèle à base de règles, décrites dans Quinlan (1992) avec des corrélations supplémentaires basées sur les voisins les plus proches dans l'ensemble d’apprentissage (voir Quinlan (1993) pour plus de détails).L’algorithme de Cubist est basé sur des règles permettant l’accumulation de modèles prédictifs basée sur des partitions du jeu de données.

### Comparaison des modèles (GBM et Cubist)

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}

##### Préparation des données pour la modélisation############################################
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

Rcovaroccup <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")

typeoccup <- replicate(length(Rcovaroccup), "occup")

Rcovarstrates <- c("zonage_cplt","zonage_simple","typo_clim","code_dept","eff_corgox9599")#test avec eff_corgco9599
typestrates <- replicate(length(Rcovarstrates), "strates")

Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato,Rcovarstrates)
type <- c(typetopo,typepedo,typeoccup,typeclimato,typestrates)
# Construction du vecteur des variables du modèle. 
vNames <- c("corgox9599",Rcovar)

# Sélection du jeu de données
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
#############################################################################################

# Paramètres de modélisation
trControl <- trainControl(method = "cv",p=0.8,number=10)
tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

# 
datax <- d[, vNames[-1]]
datay <- d[, vNames[1]]

# On lance caret pour les deux types modèles (voir https://github.com/tobigithub/caret-machine-learning/blob/master/caret-parallel/run-multiple-caret-models-parallel-lapply.R)

modelObjects <- list()
model <- c("gbm","cubist")
for(i in 1:length(model)){
  print(model[i])
  modelObjects[[model[i]]] <- train(x = datax, y = datay,model[i],tuneGrid = tuneGrid[[i]],trControl = trControl,verbose = F,keep.data = T)
  }

# Sauvegarde
save(modelObjects,file=paste(repsortie,"modelObjects.RData",sep=""))

#modelObjects <- list()
#model <- c("gbm","cubist")

#m <- c("gbm","cubist")
#t2 <- lapply(m,function(x) {set.seed(123); seeds <- vector(mode = "list", length = nrow(datax) + 1); seeds <- lapply(seeds, function(x) 1:20); t1 <- train(datax, datay, (x),trControl = trainControl(method = "cv",seeds=seeds))})
#r2 <- lapply(1:length(t2), function(x) {cat(sprintf("%-10s",(m[x])));cat(t2[[x]]$results$Rsquared[which.min(t2[[x]]$results$RMSE)],"\t"); cat(t2[[x]]$results$RMSE[which.min(t2[[x]]$results$RMSE)],"\n")})
```
```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,error=FALSE}
load(paste(repsortie,"modelObjects.RData",sep=""))
resamps <- resamples(modelObjects)
```
Ci-dessous, la figure et les tableaux présentent les résultats de la qualité de la prédicition des deux modèles sur les 10 validations croisées. Le modèle cubist présente de meilleurs résultats que le modèle gbm. Pour la précision du modèle, la médiane de la racine quarré de l'erreur quadratique moyenne du modèle cubist est de `r median(summary(resamps)$values[,"cubist~RMSE"])` tandis qu'elle est de `r median(summary(resamps)$values[,"gbm~RMSE"])` pour gbm. Les coefficients de détermination entre les deux modèles sont quasiment identique, avec un légèr avantage pour le modèle cubist.
**Le modèle Cubist sera utilisé par la suite.**

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,warning=FALSE,error=FALSE}
pander(summary(resamps)$statistics,caption="Statistiques des résultats de la validation croisée pour les modèles gbm et cubist")
p1 <- dotplot(resamps)
p2 <- parallelplot(resamps, metric = "Rsquared")
grid.arrange(p1,p2,nrow=1)
```

### Application du meilleur modèle Cubist

Ci-dessous, la modélisation avec Cubist est relancé selon l'algorithme suivant :

```{r engine='bash',eval=FALSE,}
1. Définition des paramètres de modélisation
   - Validation croisée sur les différents paramètres de modélisation (10 fois)
   - Sélection des meilleurs paramètres
2. Application du modèle avec les meilleurs paramètres (100 fois)
   - Sélection aléatoire de 80% du jeu de données pour l'apprentissage et 20% pour la validation
   - Construction du modèle sur 80% du jeu de données
   - Calcul de l'importance des variables dans le modèle
   - Prédiction sur 20% du jeu de données et comparaison avec le jeu de données initial
   - Calcul des indicateurs de qualité (R2, MSE, RMSE)
3. Calcul de la moyenne des indicateurs sur les 100 répétitions
   - Calcul de la moyenne des indicateurs de qualité sur le nombre de répétition
   - Calcul de l''importance moyenne des variables pour le nombre de répétition
```

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}
#http://stackoverflow.com/questions/24779363/return-variable-importance-for-each-iteration-in-caret-package-in-r

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

Rcovarstrates <- c("zonage_cplt","zonage_simple","typo_clim","code_dept")
typestrates <- replicate(length(Rcovarstrates), "strates")

## Construction des variables occupation du sol en fonction de la période en C étudiée
periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("med_corgox_9599","med_corgox_0004","med_corgox_0509","med_corgox_1014")
effectif <- c("eff_corgox9599","eff_corgox0004","eff_corgox0509","eff_corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

nbr <- 100
prob <- 0.8
model="cubist"
cpt <- 0

for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  # Suppression p_protea1970 (inexistant en 1970!)
  #ra_occupyears <- ra_occupyears[!ra_occupyears %in% "p_protea1970"]

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  
  # Ajout des effectifs
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato,Rcovarstrates,effectif[cpt])

  # Construction du vecteur des variables du modèle. 
  vNames <- c(i,Rcovar)

  # Sélection du jeu de données
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]

  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))
    
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
  datax <- d[,vNames[-1]]
  datay <- d[,vNames[1]]
  
  mcubist_fr <- cv_datamining(datax,datay,nbr=nbr,prob,model,select=1:15,tuneGrid,trControl,repsortie)

  saveRDS(mcubist_fr,file=paste(repsortie,"mcubist_fr_",i,"_",nbr,".rds",sep=""))
}

#nbr <- 100
#for(i in Variay){
 # modelcubistrds <- readRDS(paste(repsortie,"mcubist_fr_",i,"_",nbr,".rds",sep=""))
  #modelcubistrds <- list(varimp=modelcubistrds$varimp,meanvarimport=modelcubistrds$meanvarimport,qualityindex=modelcubistrds$qualityindex,R2=modelcubistrds$R2,RMSE=modelcubistrds$RMSE,MSE=modelcubistrds$MSE)
  #saveRDS(modelcubistrds,file=paste(repsortie,"mcubist_fr_",i,"_",nbr,"2.rds",sep=""))
#}
```

```{r,eval=TRUE,echo=FALSE,message=FALSE,warning=FALSE,error=FALSE,fig.height=9, fig.width=11,fig.align="center"}
# Ci-dessous, construction des graphiques pour calculer l'importance des variables

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

Rcovarstrates <- c("zonage_cplt","zonage_simple","typo_clim","code_dept","eff_corgox9599")#test avec eff_corgco9599
typestrates <- replicate(length(Rcovarstrates), "strates")

periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("med_corgox_9599","med_corgox_0004","med_corgox_0509","med_corgox_1014")
effectif <- c("eff_corgox9599","eff_corgox0004","eff_corgox0509","eff_corgox1014")

indexperiod <- list(1:3,1:4,1:4,1:5)

nbr <- 100
pourcent <- list()
rest <- array(NA, dim = c(length(Variay), 3),list(Period_co = Variay, mod = c("r2","MSE","RMSE")))
cpt <- 0
for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato,typestrates)

  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato,Rcovarstrates,effectif[cpt])

  varimp <- readRDS(paste(repsortie,"mcubist_fr_",i,"_",nbr,".rds",sep=""))
  qualityindex <- varimp$qualityindex
  varimp <- as.data.frame(varimp$varimp)
  varimp <- varimp[grep("Overall",names(varimp))]

  varimp$median <- apply(varimp, 1, function(x){median(x,na.rm=TRUE)})
  varimp$covariable <- rownames(varimp)
  varimp <- varimp[with(varimp, order(-median)),]
  varimp$covariable <- reorder(varimp$covariable, varimp$median)

  # Selection quantile(test$value,0.75)>40
  varimp$Q75 <- apply(varimp[,!names(varimp) %in% c("relatmed","median","covariable")],1, function(x) quantile(x, probs=0.75))
  varimp40 <- varimp[varimp$Q75>40,]
  varimp40$relatmed <- apply(varimp40[names(varimp40) %in% "median"],2,function(x){(x/sum(x))*100})

  test <- melt(varimp)
  test$type <- gsub2(as.character(Rcovar),type,as.character(test$covariable))
  pp <- list()

  pp[[1]] <- ggplot(test[!test$variable %in% c("relatmed","median","Q75"),],    aes(x=covariable,y=value,fill=type)) + geom_boxplot()+
     scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+
     coord_flip()+
     geom_hline(yintercept = 40) +
     theme_perso()  

  test2 <- melt(varimp40)
  test2$type <- gsub2(as.character(Rcovar),type,as.character(test2$covariable))
  test2$period <- rep(i,nrow(test2))

  pp[[2]] <- ggplot(test2[!test2$variable %in% c("relatmed","median","Q75"),], aes(x=covariable,y=value,fill=type)) + 
     geom_boxplot()+
     scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+
     coord_flip()+
     theme_perso()  

  tt <- do.call(grid_arrange_shared_legend,c(pp,list(nrow=1,ncol=2,position="bottom")))
  ggsave(tt,file = paste(repsortie,"ImpVariable_cubist_",i,".png",sep=""), width = 11, height = 9)  
 
  pourcent[[i]] <- test2[test2$variable %in% "relatmed",]

  rest[cpt,"r2"] <- qualityindex[,"R2"][[1]]
  rest[cpt,"MSE"] <- qualityindex[,"MSE"][[1]]
  rest[cpt,"RMSE"] <- qualityindex[,"RMSE"][[1]]
}

df <- do.call("rbind",pourcent)
df <- df[complete.cases(df),]
df$period <- factor(df$period,levels=c("med_corgox_9599","med_corgox_0004","med_corgox_0509","med_corgox_1014"))

ggplot(df,aes(x=period,y=value,fill=type,label=paste(covariable,":",round(value),"%",sep="")))+geom_col(width = 0.7) + geom_text(size = 3, position = position_stack(vjust = 0.5)) + theme_perso() + xlab("")+ylab("Pourcentage d'importance")
#ggsave(tt,file = paste(repsortie,"ImpVariable_cubist_",i,".png",sep=""), width = 11, height = 9)  
```

Les résultats de la validation croisée de la modélisation des teneurs en CO pour les différentes périodes sont présentés dans le tableau ci-dessous. Sur les 100 répétitions, l'application du modèle sur les 20% du jeu d'apprentissage montre une capacité de prédiction des teneurs en CO équivalente entre les périodes et de bonne qualité. La modélisation des teneurs en CO pour la période 2010-2014 montrent la capacité de prédiction la plus mauvaise avec un coefficient de détermination (R2) de 0.78 et un erreur moyenne (Root Mean Square Error) de 2.4 g/kg. La période 2000-2004 affiche les meilleurs avec un R2 de 0.83 et une erreur moyenne de 2.2 g/kg. En moyenne la modélisation des teneurs en CO toute période confondues affiche donc une capacité d'explication de la variance de plus de 80%.

```{r,eval=TRUE,echo=FALSE,results='asis'}
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée pour les différents modèles")
```

Les 15 variables explicatives de ces modélisations sont présentées dans la figure ci-dessous. Le taux d'argile (`argi_med`) et l'écart de pluie à la moyenne en janvier (`pluie_ecart_janv`) sont les deux premières variables explicatives des 4 modèles. Elles présentent toutes deux un pourcentage d'importance supérieur à 50%. L'altitude moyenne (`altimean`) par canton et le pourcentage de surface fourragère principale (pour différentes périodes) (`p_sfp`) sont également des variables explicatives d'importance. 

Cette dernière variable est quasiment présente sous toutes ces déclinaisons temporelles (1970, 1979, 1988, 2000, 2010). Dans une moindre mesure, le pourcentage de prairie dans la SAU et le pourcentage de maïs fourrage sont les autres variables de type occupation du sol qui ressortent régulièrement dans ce classement des 15 variables explicatives les plus importantes.

L'ordre d'importance des variables explicatives des 4 périodes des teneurs en CO ne sont pas complètement identique à défaut de la première variables explicatives (l'argile). Toutefois, on note de nombreuses similitude entre les 3 premiers modèles (1995-1999 à 2005-2009). La dernière modélisation (2010-2014) présente des résultats différents, avec une part de variable d'origine climatique plus importante.

```{r,eval=TRUE,echo=FALSE}
#do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

> **En conclusion** Ces résultats montrent que la répartition des teneurs en CO de la BDAT à l'échelle de la France est principalement expliquée par des variable d'origine naturelle (pédologique, climatique, et topographique). L'effet de l'occupation du sol apparaît secondaire. Ces résultats concordent avec les premières conclusions du travail de la modélisation avec des régressions linéaires multiples effectuées avec des co-variables naturelles ou d'origines anthropiques. 

```{r,eval=FALSE,echo=FALSE}
# Construction de la grille 
grille <- expand.grid(argi_med = quantile(d[,"argi_med"], c(seq(0,0.9,0.1),0.98)), 
                      pluie_ecart_janv = quantile(d[,"pluie_ecart_janv"],c(seq(0,0.9,0.1),0.98)),
                      altimean = quantile(d[,"altimean"],c(seq(0,0.9,0.1),0.98)),
                      p_sfp1979 = quantile(d[,"p_sfp1979"],c(seq(0,0.9,0.1),0.98)))

autre <- vNames[!(vNames %in% c("argi_med","pluie_ecart_janv","p_sfp1979","altimean"))][-1]

variaeffect(grille = grille,vNames = autre,data = d,model = mcubist,nameModel = "cubist",neighbors=tuneGrid,nomsortie="test",sortie=repsortie)
```

## Modélisation avec les années (en cours TEST)

Ici, on test la modélisation toute période confondues et on rajoute les périodes comme des éléments constructifs du modèle.

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}
#http://stackoverflow.com/questions/24779363/return-variable-importance-for-each-iteration-in-caret-package-in-r

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

Rcovarstrates <- c("zonage_cplt","zonage_simple","typo_clim","code_dept")
typestrates <- replicate(length(Rcovarstrates), "strates")

## Construction des variables occupation du sol en fonction de la période en C étudiée
periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c")#,"p_mf")
# ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("med_corgox_9599","med_corgox_0004","med_corgox_0509","med_corgox_1014")
effectif <- c("eff_corgox9599","eff_corgox0004","eff_corgox0509","eff_corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

ra_occupyears <- apply(expand.grid(ra_occup,periodra),1, function(x){paste(x[1],x[2],sep="")})
Rcovaroccup <- ra_occupyears#c(ra_otex,ra_occupyears)
typeoccup <- replicate(length(Rcovaroccup), "occup")

Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato,Rcovarstrates,effectif)

vNames <- c(Variay,Rcovar)
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
test <- melt(d,id=Rcovar)
type <- c(typetopo,typepedo,typeoccup,typeclimato,typestrates)

nbr <- 100
prob <- 0.8
model="cubist"

trControl <- trainControl(method = "cv",p=prob,number=10)
tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))
    
datax <- test[,names(test)!="value"]
datay <- test[,"value"]
 
##Long##  
mcubist_fr <- cv_datamining(datax,datay,nbr=nbr,prob,model,select=1:15,tuneGrid,trControl,repsortie)
saveRDS(mcubist_fr,file=paste(repsortie,"mcubist_fr_periodCO_",nbr,".rds",sep=""))


## ## ## 
varimp <- readRDS(paste(repsortie,"mcubist_fr_periodCO_",nbr,".rds",sep=""))
qualityindex <- varimp$qualityindex
varimp <- as.data.frame(varimp$varimp)
varimp <- varimp[grep("Overall",names(varimp))]
varimp$median <- apply(varimp, 1, function(x){median(x,na.rm=TRUE)})
varimp$covariable <- rownames(varimp)
varimp <- varimp[with(varimp, order(-median)),]
varimp$covariable <- reorder(varimp$covariable, varimp$median)

# Selection quantile(test$value,0.75)>40
varimp$Q75 <- apply(varimp[,!names(varimp) %in% c("relatmed","median","covariable")],1, function(x) quantile(x, probs=0.75))
varimp40 <- varimp[varimp$Q75>40,]
varimp40$relatmed <- apply(varimp40[names(varimp40) %in% "median"],2,function(x){(x/sum(x))*100})

test <- melt(varimp)
test$type <- gsub2(as.character(Rcovar),type,as.character(test$covariable))
pp <- list()

pp[[1]] <- ggplot(test[!test$variable %in% c("relatmed","median","Q75"),],aes(x=covariable,y=value,fill=type)) + geom_boxplot()+scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+geom_hline(yintercept = 40) +theme_perso()  

test2 <- melt(varimp40)
test2$type <- gsub2(as.character(Rcovar),type,as.character(test2$covariable))

pp[[2]] <- ggplot(test2[!test2$variable %in% c("relatmed","median","Q75"),], aes(x=covariable,y=value,fill=type)) + geom_boxplot()+scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+theme_perso()  

tt <- do.call(grid_arrange_shared_legend,c(pp,list(nrow=1,ncol=2,position="bottom")))
```


## Modélisation par type de variable (TEST)

```{r,highlight=TRUE,eval=FALSE,echo=FALSE,warning=FALSE,error=FALSE}
#http://stackoverflow.com/questions/24779363/return-variable-importance-for-each-iteration-in-caret-package-in-r

Rcovarclimato <- c("hpluie_an","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","ttemp_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

## Construction des variables occupation du sol en fonction de la période en C étudiée
Variay <- c("med_corgox_9599","med_corgox_0004","med_corgox_0509","med_corgox_1014")

nbr <- 100
prob <- 0.8
model="cubist"
cpt <- 0

for(i in Variay[1]){
  cpt <- cpt + 1
  
  # Ajout des effectifs
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovarclimato)

  # Construction du vecteur des variables du modèle. 
  vNames <- c(i,Rcovar)

  # Sélection du jeu de données
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]

  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))
    
  d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),vNames]
  datax <- d[,vNames[-1]]
  datay <- d[,vNames[1]]
  
  mcubist_fr <- cv_datamining(datax,datay,nbr=nbr,prob,model,select=1:15,tuneGrid,trControl,repsortie,type)

  saveRDS(mcubist_fr,file=paste(repsortie,"mcubist_fr_",i,"_anthrop",nbr,".rds",sep=""))
}

```

## Régressions linéaires


```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("altitude","Graphiques de correlation"),fig.align="center"}
period <- c("9599","0004","0509","1014")
xlabel <- "Altitude moyenne (m)"
ylabel <- "Teneur en CO (g/kg)"
colors <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")

p <- list()
for(i in period){
  c_period <- paste("corgox",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_p_sfp1988) & complete.cases(dcast.bdat$altimean) & complete.cases(dcast.bdat[,c_period]),]
    
  p[[i]] <- ggplot(dataplot, aes_string("altimean",c_period)) +
            geom_point(aes(colour = factor(classe_p_sfp1988)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="% de sfp (1988)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=650, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,"altimean"], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")        
}
   
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("cor_prairie1988","Graphique de correlation"),fig.align="center"}
ylabel <- "Teneur en CO (g/kg)"
colors <- brewer.pal(5,"Set1")#wes_palette("Rushmore",nperiod,type="continuous")
xlabel <- "Pourcentage de prairie en 1988"
covariable <- "p_prairie1988"

p <- list()
for(i in period){
  c_period <- paste("corgox",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,covariable]) & complete.cases(dcast.bdat[,c_period]),]
  
  p[[i]] <- ggplot(dataplot, aes_string(covariable,c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=20, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,covariable], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}

do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("correlation","Graphiques de correlation"),fig.align="center"}

period <- c("9599","0004","0509","1014")
xlabel <- "Pluie annuelle (mm)"
ylabel <- "Carbone organique (g/kg)"
colors <- brewer.pal(5,"Set1")

p <- list()
for(i in period){
  c_period <- paste("corgox",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_p_sfp1988) & complete.cases(dcast.bdat$hpluie_an) & complete.cases(dcast.bdat[,c_period]),]
#  dataplot[,c_period] <- log(dataplot[,c_period])
  
  p[[i]] <- ggplot(dataplot, aes_string("hpluie_an",c_period)) +
            geom_point(aes(colour = factor(classe_p_sfp1988)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="% de sfp (1988)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=800, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,"hpluie_an"], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
  
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=6, fig.width=10,fig.cap = fig$cap("correlation2","Graphiques de correlation"),fig.align="center"}

period <- c("9599","0004","0509","1014")
xlabel <- "SFP/SAU(%)"
ylabel <- "Carbone organique (g/kg)"
colors <- brewer.pal(5,"Set1")

p <- list()
for(i in period){
  c_period <- paste("corgox",i,sep="")
  
  dataplot <- dcast.bdat[complete.cases(dcast.bdat$classe_p_sfp1988) & complete.cases(dcast.bdat$classe_altimean) & complete.cases(dcast.bdat[,c_period]),]
#  dataplot[,c_period] <- log(dataplot[,c_period])
  
  p[[i]] <- ggplot(dataplot, aes_string("p_sfp1988",c_period)) +
            geom_point(aes(colour = factor(classe_altimean)),alpha = 0.8, size = 1) +
            #geom_point(colour="grey10", alpha = 0.1,size = 1)+
            scale_color_manual(values=colors,name="Altitude moyenne (m)")+
            scale_x_continuous(xlabel)+scale_y_continuous(ylabel)+
            theme(plot.title = element_text(size = 14, face = "bold"), 
            text = element_text(size = 12),
            axis.title = element_text(face="bold"),
            axis.text.x=element_text(size = 11))+ labs(title=i)+
            annotate("text", x=40, y=70, label=lm_eqn(lm(dataplot[,c_period]~dataplot[,"p_sfp1988"], dataplot)), parse=TRUE)+
            geom_smooth(method = "lm", se = FALSE,color="black")    
}
  
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
```

## Conclusion

A la suite de ce premier travail, la modélisation des teneurs en CO doit être reconduite à l'échelle d'un zonage où le contexte climatique, pédologique et topographique est homogène afin d'identifier les variables d'occupation du sol susceptibles d'agir sur les teneurs en CO.


# Analyse par stratification

Cette section reprend le travail de modélisation réalisé précédemment en l'appliquant à l'échelle des strates liée au type de climat et aux principales régions d'élevage.

## Analyse linéaire par stratification

Attention, dans les résultats, revoir le calcul car valeur R2 abérante. Prendre en compte la différences dans le nombre d'échantillon par strates.

```{r lmstratification_climat,eval=FALSE,echo=FALSE}
# Sélection des variables de travail
strates <- levels(as.factor(dcast.bdat$typo_clim))

# Co-variables
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")
Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
Variay <- "corgox9599"

Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop)
vNames <- c(Variay,Rcovar)

p <- list()

d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),]

for(i in strates){
  print(i)
  d_typo <- d[d$typo_clim %in% i,vNames]
  p[[i]] <- lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2]
}

#
lm_climato <- as.data.frame(p)
to <- paste("X",1:7,sep="")
from <- replicate(7, "Type")
colnames(lm_climato)[grep("nom",names(lm_climato))] <- gsub2(lm_climato[grep("nom",names(lm_climato))],to,from)
#
to <- paste("X",1:7,".R2",sep="")
from <- paste("Clim",1:7,sep="")
colnames(lm_climato)[grep("R2",names(lm_climato))] <- gsub2(lm_climato[grep("R2",names(lm_climato))],to,from)
lm_climato <- melt(lm_climato,id="Type")
```

```{r lmstratification_elevage,eval=FALSE,echo=FALSE}
# Stratification par zonage des grandes régions d'élevage
strates <- levels(as.factor(dcast.bdat$zonage_cplt))
length(strates)
p <- list()

# Co-variables
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")
Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med")
typetopo <- replicate(length(Rcovartopo), "pedologie")

Rnaturel <- c(Rcovartopo,Rcovarclimato)

Ranthrop <- c("p_sfp1988","elevage1988","elevagehorsol1988","polyelevage1988","p_prairie1970","p_prairie1979","p_prairie1988","p_sfp1970","p_sfp1979","p_mf1988","p_sth1970","p_sth1979","p_sth1988","p_mf1970","p_mf1979","clc31_90","clc21_90","clc22_90","clc23_90","clc24_90","clc31_90","ugbta1988","grdcultures1988","p_cop1970","p_cop1979","p_cop1988","p_c1988","p_c1970","p_c1979")
Variay <- "corgox9599"

Rcovar <- c(Rcovarclimato,Rcovartopo,Rcovarpedo,Ranthrop)
vNames <- c(Variay,Rcovar)

p <- list()
d <- dcast.bdat[complete.cases(dcast.bdat[vNames]),]

for(i in strates){
  print(i)
  d_typo <- d[d$zonage_cplt %in% i,vNames]
  #p[[i]] <- lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2]
  
  ptry <- try(lm_variatype(d=d_typo,Rnaturel,Ranthrop,Variay)$df[,1:2],silent=TRUE)

   if(class(ptry)[1]=="try-error"){
    print("Pas assez d'échantillons pour la modélisation")
    next
  }else{
    p[[i]] <- ptry
  }
}

#
lm_regelevage <- as.data.frame(p)
strates2 <- strates[!(strates %in% "F2")]
to <- paste(strates2,".nom",sep="")
from <- replicate(length(strates2), "Type")
colnames(lm_regelevage)[grep("nom",names(lm_regelevage))] <- gsub2(lm_regelevage[grep("nom",names(lm_regelevage))],to,from)
#
to <- paste(strates2,".R2",sep="")
from <- strates2
colnames(lm_regelevage)[grep("R2",names(lm_regelevage))] <- gsub2(lm_regelevage[grep("R2",names(lm_regelevage))],to,from)
lm_regelevage <- melt(lm_regelevage,id="Type")
```

## Analyse Cubist par stratification

L'application de la modélisation avec Cubist pour les différentes strates géographiques suit l'algorithme suivant :

```{r eval=FALSE}
Pour chaque strate :
  1. Définition des paramètres de modélisation
    - Validation croisée sur les différents paramètres de modélisation (10 fois)
    - Sélection des meilleurs paramètres
  2. Application du modèle avec les meilleurs paramètres (100 fois)
    - Sélection aléatoire de 80% du jeu de données pour l'apprentissage et 20% pour la validation
    - Construction du modèle sur 80% du jeu de données
    - Calcul de l'importance des variables dans le modèle
    - Prédiction sur 20% du jeu de données et comparaison avec le jeu de données initial
    - Calcul des indicateurs de qualité (R2, MSE, RMSE)
  - Calcul de la moyenne des indicateurs de qualité sur le nombre de répétition
  - Calcul de l''importance moyenne des variables pour le nombre de répétition
Fin
```
  
### Stratification par type de climat

Ci-dessous, la figure et le tableau présentent les résultats de la modélisation des teneurs en CO pour la période 1995-1999 au sein des strates de type de climat. Le tableau présente la moyenne des indicateurs de qualité de modélisation pour les 100 validations croisées. La figure présente la moyenne de l'importance des variables explicatives pour les 100 répétitions.

```{r cubiststratification,eval=FALSE,echo=FALSE}
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

## Construction des variables occupation du sol en fonction de la période en C étudiée
periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

nbr <- 100
prob <- 0.8
model="cubist"
strates <- 1:5
rest <- array(NA, dim = c(length(strates), 3),list(strates = strates, mod = c("r2","MSE","RMSE")))

cpt <- 0
for(i in Variay){
  print(i)
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)

  # Construction du vecteur des variables du modèle. 
  vNames <- c(i,Rcovar)
cpt1 <- 0
for(s in strates){
  print(s)
  cpt1 <- cpt1 + 1
  d_typo <- dcast.bdat[complete.cases(dcast.bdat[vNames]) & dcast.bdat$typo_clim %in% s,vNames]
  
  datax <- d_typo[, vNames[-1]]
  datay <- d_typo[, vNames[1]]
 
  # Paramètres de modélisation
  trControl <- trainControl(method = "cv",p=prob,number=10)
  tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

  # Modélisation avec les meilleurs paramètres
  mcubistbst <- cv_datamining(datax,datay,nbr=nbr,prob,model,tuneGrid,trControl,repsortie,select=1:15)
  saveRDS(mcubistbst,file=paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))

  rest[cpt1,"r2"] <- mcubistbst$qualityindex[,"R2"][[1]]
  rest[cpt1,"MSE"] <- mcubistbst$qualityindex[,"MSE"][[1]]
  rest[cpt1,"RMSE"] <- mcubistbst$qualityindex[,"RMSE"][[1]]
  }
saveRDS(rest,file=paste(repsortie,"restcubist_typoclim_",nbr,"_",i,".rds",sep=""))  
}

#nbr <- 100
#for(i in Variay){
  #for(s in strates){
  #modelcubistrds <- readRDS(paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))
  #modelcubistrds <- list(varimp=modelcubistrds$varimp,meanvarimport=modelcubistrds$meanvarimport,qualityindex=modelcubistrds$qualityindex,R2=modelcubistrds$R2,RMSE=modelcubistrds$RMSE,MSE=modelcubistrds$MSE)
  #saveRDS(modelcubistrds,file=paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,"2.rds",sep=""))
  #}
#}
```

```{r,eval=TRUE,echo=FALSE}

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
nbr <- 100
p <- list()
strates <- 1:5
cpt <- 0

for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)
  namemodel <- paste("mcubist_fr_",i,sep="")
  
  cpt1 <- 0
  pourcent <- list()
  for(s in strates){
    modelcubistrds <- readRDS(paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))
    varimp <- as.data.frame(modelcubistrds$varimp)
    varimp <- varimp[grep("Overall",names(varimp))]

    varimp$median <- apply(varimp, 1, function(x){median(x,na.rm=TRUE)})
    varimp$covariable <- rownames(varimp)
    varimp <- varimp[with(varimp, order(-median)),]
    varimp$covariable <- reorder(varimp$covariable, varimp$median)

    # Selection quantile(test$value,0.75)>40
    varimp$Q75 <- apply(varimp[,!names(varimp) %in% c("relatmed","median","covariable")],1, function(x) quantile(x, probs=0.75))
    varimp40 <- varimp[varimp$Q75>40,]
    varimp40$relatmed <- apply(varimp40[names(varimp40) %in% "median"],2,function(x){(x/sum(x))*100})

    test <- melt(varimp)
    test$type <- gsub2(as.character(Rcovar),type,as.character(test$covariable))
    pp <- list()

    pp[[1]] <- ggplot(test[!test$variable %in% c("relatmed","median","Q75"),],    aes(x=covariable,y=value,fill=type)) + geom_boxplot()+
     scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+geom_hline(yintercept = 40) +theme_perso()  

    test2 <- melt(varimp40)
    test2$type <- gsub2(as.character(Rcovar),type,as.character(test2$covariable))
    test2$strates <- rep(s,nrow(test2))

    pp[[2]] <- ggplot(test2[!test2$variable %in% c("relatmed","median","Q75"),], aes(x=covariable,y=value,fill=type)) + geom_boxplot()+scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+
     theme_perso()  

    tt <- do.call(grid_arrange_shared_legend,c(pp,list(nrow=1,ncol=2,position="bottom")))
    #ggsave(tt,file = paste(repsortie,"ImpVariable_typoclim_",s,"_",i,".png",sep=""), width = 11, height = 9)
    pourcent[[s]] <- test2[test2$variable %in% "relatmed",]
    }

    df <- do.call("rbind",pourcent)
    df <- df[complete.cases(df),]
    df$strates <- factor(df$strates,levels=c("1","2","3","4","5"))
    p[[i]] <- ggplot(df,aes(x=strates,y=value,fill=type,label=paste(covariable,":",round(value),"%",sep="")))+geom_col(width = 0.7) + geom_text(size = 3, position = position_stack(vjust = 0.5)) + theme_perso() + xlab("")+ylab("Pourcentage d'importance") + labs(title=i) 
}

tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
ggsave(tt,file = paste(repsortie,"ImpVariable_typoclim_",s,"_",i,".png",sep=""), width = 11, height = 9)
```
Sur les 3 strates climatiques modélisées, les tests de modélisation présentent des r2 de 

Le rôle des variables explicatives est différent. Pour les zones 3 et 4, le taux d'argile joue un rôle prépondérant et les variables 

Dans la zone climatique 5, les variables climatiques sont nettement plus contributrices du modèle que les variables d'occupation du sol. 

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=12, fig.width=12,fig.cap = fig$cap("cubist_strat_fr","Importance des variables explicatives"),fig.align="center",message=FALSE,warning=FALSE,results = 'asis'}
nbr <- 100
load(paste(repsortie,"restcubist_typoclim_",nbr,".RData",sep=""))
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée")
do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=3,position="bottom")))
```

### Stratification par grande région d'élevage

Ci-dessous, la figure et le tableau présentent les résultats de la modélisation des teneurs en CO pour la période 1995-1999 au sein des différentes strates d'élevage. Le tableau présente la moyenne des indicateurs de qualité de modélisation pour les 100 validations croisées. La figure présente la moyenne de l'importance des variables explicatives pour les 100 répétitions.

La qualité de la modélisation ainsi que l'importance des variables explicatives sont différentes en fonction des strates. Les régions B1 (Zone de polyculture-élevage du Bassin Parisien) et C1 (Zone intensive du Grand Ouest) présentent les meilleurs résultats de modélisation avec un R2 moyen de 0.83 et 0.86 respectivement. 

La modélisation des teneurs en CO dans la région B1 est essentiellement basée sur les variables naturelles. La teneur en argile est la principale variable explicative. Les variables climatiques et la topographie occupent une part importante. Les variables d'occupation du sol ont une faible part dans la modélisation avec moins de 25%. Parmi celles-ci, ce sont les pourcentage de SFP, de prairie, de COP et de maïs fourrage dans la SAU qui sont le mieux représentés. On retrouve un classement similaire pour C1. L'argile et la topographie sont d'une moindre importance dans la modélisation et ce sont surtout les variables climatiques qui expliquent les teneurs en CO. Dans cette région, l'OTEX elevage 1988 et les pourcentages en STH sont les principales variables explicatives de type d'occupation du sol. A noter que ces régions 

```{r ,eval=FALSE,echo=FALSE}
reg_elevage <- c("A","B1","B2","C1","D","E1","E2","G1","G2")
rest <- array(NA, dim = c(length(reg_elevage), 3),list(strates = reg_elevage, mod = c("r2","MSE","RMSE")))
nbr <- 100
prob <- 0.8
cpt <- 0
model <- "cubist"
Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

## Construction des variables occupation du sol en fonction de la période en C étudiée
periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

cpt <- 0
for(i in Variay){
  print(i)
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)

  # Construction du vecteur des variables du modèle. 
  vNames <- c(i,Rcovar)
  cpt1 <- 0
  for(s in reg_elevage){
    cpt1 <- cpt + 1
    print(s)
  
    d_typo <- dcast.bdat[complete.cases(dcast.bdat[vNames]) & dcast.bdat$zonage_cplt %in% s,vNames]
  
    datax <- d_typo[, vNames[-1]]
    datay <- d_typo[, vNames[1]]
 
    # Paramètres de modélisation
    trControl <- trainControl(method = "cv",p=prob,number=10)
    tuneGrid <- list(gbm=expand.grid(interaction.depth = c(1, 5, 9),n.trees = (1:10)*150,shrinkage = 0.1,n.minobsinnode = 10),cubist=expand.grid(.committees = c(10,50,100),.neighbors = c(1,5,9)))

    # Modélisation avec les meilleurs paramètres
    mcubistbst <- cv_datamining(datax,datay,nbr=nbr,prob,model,tuneGrid,trControl,repsortie,select=1:15)
    saveRDS(mcubistbst,file=paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))
    
    rest[cpt1,"r2"] <- mcubistbst$qualityindex[,"R2"][[1]]
    rest[cpt1,"MSE"] <- mcubistbst$qualityindex[,"MSE"][[1]]
    rest[cpt1,"RMSE"] <- mcubistbst$qualityindex[,"RMSE"][[1]]
  }
saveRDS(rest,file=paste(repsortie,"restcubist_elevage_",nbr,"_",i,".rds",sep=""))  
}

#nbr <- 100
#for(i in Variay){
  #for(s in reg_elevage){
  #modelcubistrds <- readRDS(paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))
  #modelcubistrds <- list(varimp=modelcubistrds$varimp,meanvarimport=modelcubistrds$meanvarimport,qualityindex=modelcubistrds$qualityindex,R2=modelcubistrds$R2,RMSE=modelcubistrds$RMSE,MSE=modelcubistrds$MSE)
  #saveRDS(modelcubistrds,file=paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,"2.rds",sep=""))
  #}
#}
```

Ci-dessous, les figures sont à commenter

```{r,eval=TRUE,echo=FALSE,warning=FALSE,message=FALSE,error=FALSE,fig.height=10, fig.width=10,fig.align="center"}

Rcovarclimato <- c("hpluie_an","jfroids_an","ampli_t_juil_janv","pluie_ecart_janv","pluie_ecart_juil","jpluie_janv","jpluie_juil","ttemp_an","jchauds_an")
typeclimato <- replicate(length(Rcovarclimato), "climat")

Rcovartopo <- "altimean"
typetopo <- replicate(length(Rcovartopo), "topographie")

Rcovarpedo <- c("argi_med","sabt_med","mat11")
typepedo <- replicate(length(Rcovarpedo), "pedologie")

periodra <- c("1970","1979","1988","2000","2010")
ra_occup <- c("p_sfp","p_prairie","p_sth","p_cop","p_c","p_mf")
ra_otex <- c("polyelevage1988","elevage1988","elevagehorsol1988","ugbta1988","grdcultures1988")
Variay <- c("corgox9599","corgox0004","corgox0509","corgox1014")
indexperiod <- list(1:3,1:4,1:4,1:5)

nbr <- 100
p <- list()
reg_elevage <- c("A","B1","B2","C1","D","E1","E2","G1","G2")
cpt <- 0

for(i in Variay){
  cpt <- cpt + 1
  ra_occupyears <- apply(expand.grid(ra_occup,periodra[indexperiod[[cpt]]]),1, function(x){paste(x[1],x[2],sep="")})

  Rcovaroccup <- c(ra_otex,ra_occupyears)
  typeoccup <- replicate(length(Rcovaroccup), "occup")
  type <- c(typetopo,typepedo,typeoccup,typeclimato)
  Rcovar <- c(Rcovartopo,Rcovarpedo,Rcovaroccup,Rcovarclimato)
    
  pourcent <- list()
  for(s in reg_elevage){
    pp <- list()
    modelcubistrds <- readRDS(paste(repsortie,"mcubist_strates_",s,"_",i,"_",nbr,".rds",sep=""))
    varimp <- as.data.frame(modelcubistrds$varimp)
    varimp <- varimp[grep("Overall",names(varimp))]

    varimp$median <- apply(varimp, 1, function(x){median(x,na.rm=TRUE)})
    varimp$covariable <- rownames(varimp)
    varimp <- varimp[with(varimp, order(-median)),]
    varimp$covariable <- reorder(varimp$covariable, varimp$median)

    # Selection quantile(test$value,0.75)>30
    varimp$Q75 <- apply(varimp[,!names(varimp) %in% c("relatmed","median","covariable")],1, function(x) quantile(x, probs=0.75))
    varimp40 <- varimp[varimp$Q75>30,]
    varimp40$relatmed <- apply(varimp40[names(varimp40) %in% "median"],2,function(x){(x/sum(x))*100})

    test <- melt(varimp)
    test$type <- gsub2(as.character(Rcovar),type,as.character(test$covariable))

    pp[[1]] <- ggplot(test[!test$variable %in% c("relatmed","median","Q75"),],    aes(x=covariable,y=value,fill=type)) + geom_boxplot()+
     scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+geom_hline(yintercept = 30) +theme_perso()  

    test2 <- melt(varimp40)
    test2$type <- gsub2(as.character(Rcovar),type,as.character(test2$covariable))
    test2$strates <- rep(s,nrow(test2))

    pp[[2]] <- ggplot(test2[!test2$variable %in% c("relatmed","median","Q75"),], aes(x=covariable,y=value,fill=type)) + geom_boxplot()+scale_x_discrete("Variables")+scale_y_continuous("Importance des variables (%)")+coord_flip()+
     theme_perso()  

    tt <- do.call(grid_arrange_shared_legend,c(pp,list(nrow=1,ncol=2,position="bottom")))
    #ggsave(tt,file = paste(repsortie,"ImpVariable_regelevage_",s,"_",i,".png",sep=""), width = 11, height = 9)
    pourcent[[s]] <- test2[test2$variable %in% "relatmed",]
    }

    df <- do.call("rbind",pourcent)
    df <- df[complete.cases(df),]
    #df$strates <- factor(df$strates,levels=c("2","3","4","5"))
    p[[i]] <- ggplot(df,aes(x=strates,y=value,fill=type,label=paste(covariable,":",round(value),"%",sep="")))+geom_col(width = 0.7) + geom_text(size = 3, position = position_stack(vjust = 0.5)) + theme_perso() + xlab("")+ylab("Pourcentage d'importance") + labs(title=i) 
}

tt <- do.call(grid_arrange_shared_legend,c(p,list(nrow=2,ncol=2,position="bottom")))
ggsave(tt,file = paste(repsortie,"ImpVariable_regelevage_",s,"_",i,".png",sep=""), width = 11, height = 9)
```

```
Ci-dessous, commenter les résultats de la stratification avec les principales régions d'élevage

```{r,highlight=TRUE,eval=TRUE,echo=FALSE,fig.height=12, fig.width=12,fig.cap = fig$cap("cubist_strat_elevage","Importance des variables explicatives"),fig.align="center",message=FALSE,warning=FALSE,results = 'asis'}
load(paste(repsortie,"restcubist_elevage_",nbr,".RData",sep=""))
pander(as.data.frame(rest),caption="Moyenne des indicateurs de la validation croisée")
```

## Conclusion

Ici, on pourra conclure sur les résultats de modélisation par stratification




# Conclusion générale

Dans ce premier travail